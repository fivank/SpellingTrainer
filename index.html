<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SpellMaster</title>
<style>
    /* --- VARIABLES & RESET --- */
    :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --bg-body: #f3f4f6;
        --bg-card: #ffffff;
        --text-main: #1f2937;
        --text-sub: #6b7280;
        --success: #10b981;
        --error: #ef4444;
        --nav-height: 72px;
        --radius: 16px;
        /* additional neutral colour used for toggles */
        --neutral-200: #e5e7eb;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg-body);
        color: var(--text-main);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    /* --- LAYOUT --- */
    header {
        padding: 1rem;
        background: var(--bg-card);
        text-align: center;
        font-weight: 800;
        font-size: 1.2rem;
        color: var(--primary);
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        z-index: 10;
        flex-shrink: 0;
    }

    main {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        padding-bottom: calc(var(--nav-height) + 120px + env(safe-area-inset-bottom));
        max-width: 600px;
        width: 100%;
        margin: 0 auto;
        scroll-padding-bottom: calc(var(--nav-height) + 120px + env(safe-area-inset-bottom));
    }

    .view { display: none; min-height: 100%; }
    .view.active { display: block; animation: fadeIn 0.3s ease; }

    /* --- NAVIGATION --- */
    nav {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: var(--nav-height);
        background: var(--bg-card);
        border-top: 1px solid #e5e7eb;
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 20;
        padding-bottom: env(safe-area-inset-bottom);
    }

    nav button {
        background: none;
        border: none;
        color: var(--text-sub);
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 0.75rem;
        width: 100%;
        height: 100%;
        justify-content: center;
        cursor: pointer;
    }

    nav button svg { width: 24px; height: 24px; margin-bottom: 4px; fill: currentColor; overflow: visible; }
    nav button.active { color: var(--primary); }

    /* --- COMPONENTS --- */
    .card {
        background: var(--bg-card);
        border-radius: var(--radius);
        padding: 1.5rem;
        box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
        margin-bottom: 1rem;
    }

    button { cursor: pointer; border: none; font-family: inherit; font-weight: 600; transition: transform 0.1s; outline: none; }
    button:active { transform: scale(0.96); }

    .btn-primary {
        background: var(--primary);
        color: white;
        padding: 14px;
        border-radius: 12px;
        width: 100%;
        font-size: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
    }
    .btn-primary:disabled {
        background: #d1d5db;
        color: #6b7280;
        box-shadow: none;
        cursor: not-allowed;
    }
    
    .btn-secondary {
        background: transparent;
        color: var(--primary);
        border: 2px solid var(--primary);
        padding: 10px 16px;
        border-radius: 10px;
        font-weight: 600;
    }
    
    .btn-icon { background: #f3f4f6; padding: 8px; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; }

    input, select {
        width: 100%;
        padding: 14px;
        border: 2px solid #e5e7eb;
        border-radius: 12px;
        font-size: 1rem;
        background: #f9fafb;
        margin-bottom: 1rem;
        -webkit-appearance: none; /* Fix for iOS input styles */
    }
    input:focus { border-color: var(--primary); outline: none; background: #fff; }

    /* --- PRACTICE SCREEN --- */
    .practice-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 80%;
    }

    .audio-trigger {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
        margin-bottom: 2rem;
        transition: transform 0.2s;
        cursor: pointer;
        position: relative;
    }
    .audio-trigger:active { transform: scale(0.95); }
    .audio-trigger.playing { animation: pulse 1.5s infinite; }
    .audio-trigger svg { width: 50px; height: 50px; fill: white; }

    .word-input {
        font-size: 2rem;
        text-align: center;
        border: none;
        border-bottom: 3px solid #e5e7eb;
        border-radius: 0;
        background: transparent;
        color: var(--primary);
        letter-spacing: 1px;
        font-weight: bold;
    }
    .word-input:focus { border-color: var(--primary); background: transparent; }
    
    .feedback-area { text-align: center; margin-bottom: 1rem; min-height: 24px; }
    .diff-display span { font-size: 1.5rem; font-weight: 700; }
    .diff-correct { color: var(--success); }
    .diff-wrong { color: var(--error); text-decoration: line-through; margin-right: 8px; opacity: 0.7; }

    .srs-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; margin-top: 2rem; }
    .srs-btn { padding: 16px; border-radius: 12px; font-size: 0.9rem; font-weight: 700; color: #333; }
    .srs-again { background: #fee2e2; color: #991b1b; }
    .srs-hard { background: #ffedd5; color: #9a3412; }
    .srs-good { background: #dcfce7; color: #166534; }
    .srs-easy { background: #dbeafe; color: #1e40af; }

    /* --- DECK LIST --- */
    .deck-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 1rem;
        border-bottom: 1px solid #f3f4f6;
        margin-bottom: 1rem;
    }
    .deck-item:last-child { border: none; margin-bottom: 0; padding-bottom: 0; }
    .deck-info h3 { margin: 0 0 4px 0; font-size: 1.1rem; }
    .deck-info small { color: var(--text-sub); }
    
    /* --- MODAL --- */
    .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 100;
        display: flex; align-items: center; justify-content: center;
        opacity: 0; pointer-events: none; transition: opacity 0.2s;
        backdrop-filter: blur(2px);
    }
    .modal-overlay.open { opacity: 1; pointer-events: auto; }
    .modal {
        background: white; width: 90%; max-width: 400px;
        padding: 1.5rem; border-radius: var(--radius);
        transform: translateY(20px); transition: transform 0.2s;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }
    .modal-overlay.open .modal { transform: translateY(0); }
    .modal-toggle {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 1rem;
    }
    .modal-toggle button {
        padding: 10px;
        border-radius: 10px;
        border: 2px solid var(--primary);
        background: transparent;
        color: var(--primary);
        font-weight: 600;
    }
    .modal-toggle button.active {
        background: var(--primary);
        color: white;
    }
    .modal-panel.hidden {
        display: none;
    }

    .deck-actions {
        display: grid;
        gap: 10px;
    }

    .deck-actions .btn-secondary,
    .deck-actions .btn-primary {
        width: 100%;
    }
    
    /* --- ANIMATIONS --- */
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(99, 102, 241, 0); } 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    .hidden { display: none !important; }
    .status-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; margin-top: 5px; }
    .status-ok { background: #dcfce7; color: #166534; }
    .status-err { background: #fee2e2; color: #991b1b; }

    /* Diff display styling for incorrect answers */
    .diff-display {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 8px;
        margin-bottom: 8px;
        font-size: 1.2rem;
    }
    .diff-wrong { color: var(--error); text-decoration: line-through; }
    .diff-correct { color: var(--success); font-weight: bold; }

    .practice-selection {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    .practice-deck-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 12px;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        background: #f9fafb;
        transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
    }
    .practice-deck-item input {
        margin: 0;
        width: auto;
        accent-color: var(--primary);
    }
    .practice-deck-item.selected {
        border-color: var(--primary);
        background: #eef2ff;
        box-shadow: 0 6px 12px rgba(99, 102, 241, 0.15);
    }
    .practice-deck-details {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
    }
    .practice-deck-name {
        font-weight: 600;
        font-size: 0.98rem;
    }
    .practice-deck-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 0.78rem;
        color: var(--text-sub);
    }
    .practice-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 12px 0 4px;
    }
    .practice-filter-btn {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid #e5e7eb;
        background: #f3f4f6;
        color: var(--text-sub);
        font-size: 0.8rem;
        font-weight: 600;
    }
    .practice-filter-btn.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
    }
    .practice-header {
        display: flex;
        justify-content: flex-end;
        width: 100%;
        margin-bottom: 1rem;
    }
    .practice-end {
        color: var(--error);
        border-color: var(--error);
    }
    .practice-category-title {
        font-size: 0.95rem;
        color: var(--text-sub);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin: 10px 0 0;
    }
    .practice-category {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    .practice-empty {
        font-size: 0.9rem;
        color: var(--text-sub);
        margin: 0 0 8px;
    }

    /* Toggle switch styling (borrowed from improved version) */
    .toggle {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
    }
    .toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--neutral-200);
        transition: 0.4s;
        border-radius: 24px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
    }
    .toggle input:checked + .slider {
        background-color: var(--primary);
    }
    .toggle input:checked + .slider:before {
        transform: translateX(26px);
    }
</style>
</head>
<body>

<header>SpellMaster</header>

<main>
    <!-- PRACTICE SCREEN -->
    <div id="view-practice" class="view active">
        <div class="practice-wrapper" id="practice-container">
            <!-- Dynamic Content -->
            <div style="text-align: center; color: var(--text-sub);">
                <h2>Ready to Practice?</h2>
                <p>Select a deck from the Words tab to begin.</p>
                <br>
                <button class="btn-primary" onclick="navTo('words')">Go to Decks</button>
            </div>
        </div>
    </div>

    <!-- WORDS / DECKS SCREEN -->
    <div id="view-words" class="view">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h2>My Decks</h2>
            <button class="btn-secondary" onclick="openDeckModal()">+ New</button>
        </div>
        <div class="card" id="deck-list-container">
            <div id="deck-list"></div>
        </div>
    </div>

    <!-- SETTINGS SCREEN -->
    <div id="view-settings" class="view">
        <h2>Settings</h2>
        
        <!-- Learning Settings -->
        <div class="card">
            <h3>Learning</h3>
            <div>
                <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span>Autoplay audio</span>
                    <label class="toggle"><input type="checkbox" id="setting-autoplay"><span class="slider"></span></label>
                </label>
                <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span>Block keyboard suggestions</span>
                    <label class="toggle"><input type="checkbox" id="setting-block-suggestions"><span class="slider"></span></label>
                </label>
                <label style="display:block; margin-bottom:8px;">
                    Answer strictness
                    <select id="setting-strictness" style="width:100%; margin-top:4px;">
                        <option value="strict">Strict</option>
                        <option value="lenient">Lenient</option>
                    </select>
                </label>
                <label style="display:block;">
                    Timer start
                    <select id="setting-timerStart" style="width:100%; margin-top:4px;">
                        <option value="show">On show</option>
                        <option value="audio">On audio</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="card">
            <h3>Audio Diagnostics</h3>
            <p style="font-size:0.9rem; color: var(--text-sub);">If audio isn't working, check here.</p>
            <div id="audio-status" class="status-badge status-err">Checking...</div>
            <div style="margin-top:10px;">
                <label>Voice mode</label>
                <select id="setting-voice-mode">
                    <option value="auto">Auto (match deck language)</option>
                    <option value="fixed">Fixed (use selected voice)</option>
                </select>
                <p style="font-size:0.8rem; color: var(--text-sub); margin: 6px 0 12px;">
                    Auto mode chooses a voice that matches the deck language (e.g., Spanish decks use Spanish voices).
                </p>
            </div>
            <div>
                <label>System Voice</label>
                <select id="setting-voice"><option>Loading voices...</option></select>
            </div>
            <div>
                <label>Speed: <span id="speed-val">1.0</span>x</label>
                <input type="range" id="setting-speed" min="0.5" max="1.5" step="0.1" value="1">
            </div>
            <button class="btn-secondary" onclick="testAudio()">Test Audio</button>
        </div>
        
        <div class="card">
            <h3>Data Management</h3>
            <button class="btn-secondary" onclick="exportData()" style="width:100%; margin-bottom:10px;">Export Backup</button>
            <button class="btn-secondary" onclick="document.getElementById('import-file').click()" style="width:100%; margin-bottom:10px;">Import Backup</button>
            <input type="file" id="import-file" class="hidden" accept=".json">
            <button class="btn-secondary" style="color: var(--error); border-color: var(--error); width:100%;" onclick="resetApp()">Reset All Data</button>
        </div>
    </div>

    <!-- PROGRESS SCREEN -->
    <div id="view-progress" class="view">
        <h2>Progress</h2>
        <div class="card" id="progress-overview" style="margin-bottom:1rem;"></div>
        <div class="card" id="progress-details"></div>
    </div>

    <!-- DECK PROGRESS SCREEN -->
    <div id="view-deck-progress" class="view">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:1rem;">
            <button class="btn-secondary" onclick="navTo('words')" style="padding: 10px 16px;">← Back</button>
            <h2 style="margin:0;" id="deck-progress-title">Deck Progress</h2>
            <button class="btn-secondary" id="deck-reset-stats" onclick="resetDeckStats()" style="padding: 10px 16px;">Reset Stats</button>
        </div>
        <div class="card" id="deck-progress-overview" style="margin-bottom:1rem;"></div>
        <div class="card" id="deck-progress-details"></div>
    </div>
</main>

<nav>
    <button onclick="navTo('practice')" id="nav-practice" class="active">
        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
        Practice
    </button>
    <button onclick="navTo('words')" id="nav-words">
        <svg viewBox="0 0 24 24"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z"/></svg>
        Words
    </button>
    <button onclick="navTo('progress')" id="nav-progress">
        <svg viewBox="0 0 24 24"><path d="M3 17h4V9H3v8zm6 0h4V5H9v12zm6 0h4V13h-4v4z"/></svg>
        Progress
    </button>

    <button onclick="navTo('settings')" id="nav-settings">
        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L5.09 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.58 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
        Settings
    </button>
</nav>

<!-- ADD DECK MODAL -->
<div id="deck-modal" class="modal-overlay">
    <div class="modal">
        <h3>New Deck</h3>
        <div class="modal-toggle">
            <button type="button" id="deck-toggle-create" class="active" onclick="showDeckPanel('create')">Create</button>
            <button type="button" id="deck-toggle-import" onclick="showDeckPanel('import')">Import</button>
        </div>
        <div id="deck-panel-create" class="modal-panel">
            <label>Deck Name</label>
            <input type="text" id="new-deck-name" placeholder="e.g. Spanish Basics">
            <label>Language</label>
            <select id="new-deck-lang">
                <option value="en-US">English (US)</option>
                <option value="en-GB">English (UK)</option>
                <option value="es-ES">Spanish</option>
                <option value="fr-FR">French</option>
                <option value="de-DE">German</option>
                <option value="it-IT">Italian</option>
            </select>
            <div style="display:flex; gap:10px; margin-top:1rem;">
                <button class="btn-secondary" onclick="closeDeckModal()" style="flex:1">Cancel</button>
                <button class="btn-primary" onclick="saveDeck()" style="flex:1">Create</button>
            </div>
        </div>
        <div id="deck-panel-import" class="modal-panel hidden">
            <p style="font-size:0.95rem; color:var(--text-sub); margin-top:0;">
                Import a compatible deck JSON file to add it to your collection.
            </p>
            <button class="btn-secondary" onclick="triggerDeckImport()" style="width:100%; margin-bottom:10px;">Choose Deck File</button>
            <button class="btn-secondary" onclick="focusDeckPaste()" style="width:100%; margin-bottom:10px;">Paste Deck as JSON</button>
            <input type="file" id="import-deck-file" class="hidden" accept=".json,application/json">
            <div style="margin-bottom:10px;">
                <label for="import-deck-json" style="display:block; font-size:0.85rem; color:var(--text-sub); margin-bottom:6px;">
                    Paste deck as JSON
                </label>
                <textarea id="import-deck-json" rows="6" placeholder='{"name":"My Deck","lang":"en-US","cards":[{"word":"example","sentence":""}]}' style="width:100%; padding:12px; border:2px solid #e5e7eb; border-radius:12px; font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical;"></textarea>
            </div>
            <button class="btn-secondary" onclick="importDeckFromPaste()" style="width:100%; margin-bottom:10px;">Import Pasted Deck</button>
            <div style="display:flex; gap:10px;">
                <button class="btn-secondary" onclick="closeDeckModal()" style="flex:1">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- MANAGE CARDS MODAL -->
<div id="cards-modal" class="modal-overlay">
    <div class="modal" style="max-height: 85vh; display:flex; flex-direction:column;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3>Manage Cards</h3>
            <button class="btn-icon" onclick="closeCardsModal()">✕</button>
        </div>
        <div style="margin-bottom:1rem;">
            <input type="text" id="new-card-word" placeholder="Word to spell" style="margin-bottom:8px;">
            <input type="text" id="new-card-sentence" placeholder="Sentence (optional)" style="margin-bottom:8px;">
            <!-- Optional audio URL input to support custom pronunciation files -->
            <input type="text" id="new-card-audio" placeholder="Audio URL (optional)" style="margin-bottom:8px;">
            <button class="btn-primary" onclick="addCardToDeck()">Add Card</button>
        </div>
        <div style="flex:1; overflow-y:auto; border-top:1px solid #eee; padding-top:10px;" id="cards-list-content">
            <!-- Cards list -->
        </div>
    </div>
</div>

<!-- DECK ACTIONS MODAL -->
<div id="deck-actions-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3 id="deck-actions-title">Deck Actions</h3>
            <button class="btn-icon" onclick="closeDeckActionsModal()">✕</button>
        </div>
        <div class="deck-actions">
            <button class="btn-primary" onclick="openDeckStats()">Stats</button>
            <button class="btn-secondary" onclick="openDeckEditor()">Edit Words</button>
            <button class="btn-secondary" onclick="openDeckMetaEditor()">Edit Name/Language</button>
            <button class="btn-secondary" onclick="exportDeck()">Export Deck</button>
            <button class="btn-secondary" style="color: var(--error); border-color: var(--error);" onclick="deleteDeck()">Delete Deck</button>
        </div>
    </div>
</div>

<!-- EDIT DECK META MODAL -->
<div id="deck-meta-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3>Edit Name/Language</h3>
            <button class="btn-icon" onclick="closeDeckMetaModal()">✕</button>
        </div>
        <label for="edit-deck-name">Deck Name</label>
        <input type="text" id="edit-deck-name" placeholder="Deck name">
        <label for="edit-deck-lang">Language</label>
        <select id="edit-deck-lang">
            <option value="en-US">English (US)</option>
            <option value="en-GB">English (UK)</option>
            <option value="es-ES">Spanish</option>
            <option value="fr-FR">French</option>
            <option value="de-DE">German</option>
            <option value="it-IT">Italian</option>
        </select>
        <div style="display:flex; gap:10px;">
            <button class="btn-secondary" onclick="closeDeckMetaModal()" style="flex:1">Cancel</button>
            <button class="btn-primary" onclick="saveDeckMeta()" style="flex:1">Save</button>
        </div>
    </div>
</div>

<script>
/**
 * APP DATA
 */
let app = {
    decks: [],
    settings: {
        voiceURI: null,
        voiceMode: 'auto',
        speed: 1.0,
        /* whether to automatically play audio when a card appears */
        autoplay: true,
        /* whether to block keyboard suggestions on the practice input */
        blockSuggestions: false,
        /* answer strictness: 'strict' = case-sensitive; 'lenient' = case-insensitive */
        strictness: 'strict',
        /* when to start timing user response: 'show' or 'audio' */
        timerStart: 'audio'
    }
};

let currentSession = {
    deck: null,
    decks: [],
    queue: [],
    currentCard: null,
    currentEntry: null,
    isAnswered: false,
    isActive: false,
    lastAnswerCorrect: null,
    selectedDeckIds: [],
    practiceFilter: 'all',
    startTime: null
};

// --- AUDIO ENGINE (ROBUST VERSION) ---
let availableVoices = [];

function initAudio() {
    const statusEl = document.getElementById('audio-status');
    const select = document.getElementById('setting-voice');

    if (!('speechSynthesis' in window)) {
        statusEl.className = 'status-badge status-err';
        statusEl.textContent = 'Not Supported in this Browser';
        select.innerHTML = '<option>Not available</option>';
        return;
    }

    // Attempt to load voices
    const loadVoices = () => {
        const freshVoices = window.speechSynthesis.getVoices();
        if (freshVoices.length > 0) {
            availableVoices = freshVoices;
            statusEl.className = 'status-badge status-ok';
            statusEl.textContent = 'Engine Ready';
            populateVoiceSelect();
            return true;
        }
        // Keep waiting or show warning
        statusEl.className = 'status-badge status-err';
        statusEl.textContent = 'Voices Empty (Try Chrome/Safari)';
        return false;
    };

    // Modern browsers load async
    window.speechSynthesis.onvoiceschanged = loadVoices;
    
    // Initial attempt
    loadVoices();
    
    // Some browsers need a kick
    setTimeout(loadVoices, 500);

    // Keep retrying briefly for browsers that populate voices late.
    let retries = 0;
    const retryTimer = setInterval(() => {
        retries += 1;
        const loaded = loadVoices();
        if (loaded || retries >= 10) {
            clearInterval(retryTimer);
        }
    }, 500);
}

function normalizeLangCode(lang) {
    return lang ? String(lang).replace('_', '-').toLowerCase() : '';
}

function getBestVoiceForLang(lang) {
    if (!lang) return null;
    const normalized = normalizeLangCode(lang);
    const baseLang = normalized.split('-')[0];
    const exactMatches = availableVoices.filter(v => normalizeLangCode(v.lang) === normalized);
    const baseMatches = availableVoices.filter(v => {
        const voiceLang = normalizeLangCode(v.lang);
        return voiceLang && voiceLang.startsWith(baseLang);
    });
    const candidates = exactMatches.length ? exactMatches : baseMatches;
    if (!candidates.length) return null;
    return candidates.find(v => v.default) || candidates.find(v => v.localService) || candidates[0];
}

function updateVoiceModeUI() {
    const modeEl = document.getElementById('setting-voice-mode');
    const voiceSelect = document.getElementById('setting-voice');
    if (!modeEl || !voiceSelect) return;
    voiceSelect.disabled = modeEl.value === 'auto';
}

function populateVoiceSelect() {
    const select = document.getElementById('setting-voice');
    select.innerHTML = '';
    
    // Group by language
    availableVoices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI;
        opt.textContent = `${v.name} (${v.lang})`;
        select.appendChild(opt);
    });

    // Restore saved choice
    if (app.settings.voiceURI) {
        // Verify it still exists
        const exists = availableVoices.find(v => v.voiceURI === app.settings.voiceURI);
        if (exists) select.value = app.settings.voiceURI;
    }
    updateVoiceModeUI();
}

function speak(text, lang) {
    if (!('speechSynthesis' in window)) {
        alert("Your browser does not support Audio. Please try Chrome or Safari.");
        return;
    }

    if (availableVoices.length === 0) {
        const freshVoices = window.speechSynthesis.getVoices();
        if (freshVoices.length > 0) {
            availableVoices = freshVoices;
            populateVoiceSelect();
        }
    }
    
    window.speechSynthesis.cancel(); // Stop current

    const u = new SpeechSynthesisUtterance(text);
    u.rate = parseFloat(app.settings.speed) || 1.0;
    
    // --- VOICE SELECTION LOGIC ---
    let voice = null;
    
    // 1. Try User Preference when fixed mode is enabled
    if (app.settings.voiceMode === 'fixed' && app.settings.voiceURI) {
        voice = availableVoices.find(v => v.voiceURI === app.settings.voiceURI);
    }
    
    // 2. If no preference or invalid, find best match for Deck Language
    if (!voice && lang) {
        voice = getBestVoiceForLang(lang);
    }

    if (voice) {
        u.voice = voice;
        u.lang = voice.lang; // Ensure lang matches voice
    } else {
        // 3. Last Resort: Let browser decide based on lang code
        u.lang = lang || 'en-US';
    }

    // Visual Feedback
    const btn = document.querySelector('.audio-trigger');
    if(btn) btn.classList.add('playing');

    u.onend = () => { if(btn) btn.classList.remove('playing'); };
    u.onerror = (e) => { 
        if(btn) btn.classList.remove('playing');
        console.warn("Audio Error:", e);
    };

    window.speechSynthesis.speak(u);
}

function testAudio() {
    const modeEl = document.getElementById('setting-voice-mode');
    const s = document.getElementById('setting-voice');
    let lang = 'en-US';
    if (modeEl && modeEl.value === 'fixed') {
        const v = availableVoices.find(v => v.voiceURI === s.value);
        lang = v ? v.lang : lang;
    } else {
        lang = app.decks.length > 0 ? app.decks[0].lang : lang;
    }
    speak("This is a test of the audio system.", lang);
}

// --- PERSISTENCE ---
function loadData() {
    const raw = localStorage.getItem('spellmaster_data_v2');
    if (raw) {
        try {
            const data = JSON.parse(raw);
            app.decks = data.decks || [];
            app.settings = { ...app.settings, ...data.settings };
        } catch(e) { console.error("Data load error", e); }
    }
    // Ensure all cards have expected properties (migration for newer versions)
    app.decks.forEach(deck => {
        if (deck.uncompleted === undefined) deck.uncompleted = false;
        if (deck.lastPracticed === undefined) deck.lastPracticed = null;
        deck.cards.forEach(card => {
            if (card.audioUrl === undefined) card.audioUrl = '';
            if (card.correctCount === undefined) card.correctCount = 0;
            if (card.incorrectCount === undefined) card.incorrectCount = 0;
            if (card.avgTime === undefined) card.avgTime = 0;
            if (card.interval === undefined) card.interval = 0;
            if (card.ease === undefined) card.ease = 2.5;
            if (card.due === undefined) card.due = 0;
        });
    });
    renderDeckList();
    initSettingsListeners();
    renderPracticeHome();
}

function saveData() {
    localStorage.setItem('spellmaster_data_v2', JSON.stringify(app));
}

// --- NAV ---
function navTo(screen) {
    document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
    document.getElementById('view-' + screen).classList.add('active');
    
    document.querySelectorAll('nav button').forEach(el => el.classList.remove('active'));
    const navBtn = document.getElementById('nav-' + screen);
    if (navBtn) navBtn.classList.add('active');
    
    if (screen === 'words') {
        renderDeckList();
    } else if (screen === 'progress') {
        renderProgress();
    } else if (screen === 'practice') {
        if (!currentSession.isActive) {
            renderPracticeHome();
        }
    }
}

// --- PRACTICE ---
function startPractice(deckIds) {
    const selectedDecks = app.decks.filter(d => deckIds.includes(d.id));
    if (!selectedDecks.length) return;
    
    // Sort by due date
    const now = Date.now();
    currentSession.queue = selectedDecks.flatMap(deck => (
        deck.cards.filter(card => card.due <= now)
            .map(card => ({ deck, card }))
    )).sort((a,b) => a.card.due - b.card.due);
    
    // If no due cards, practice all
    if (currentSession.queue.length === 0) {
        currentSession.queue = selectedDecks.flatMap(deck => (
            deck.cards.map(card => ({ deck, card }))
        ));
    }

    if (currentSession.queue.length === 0) {
        alert("No cards available in the selected decks.");
        return;
    }

    currentSession.deck = null;
    currentSession.decks = selectedDecks;
    currentSession.isActive = true;
    navTo('practice');
    nextCard();
}

function startPracticeFromSelection() {
    const selected = currentSession.selectedDeckIds || [];
    if (!selected.length) {
        alert("Select at least one deck to practice.");
        return;
    }
    startPractice(selected);
}

function endPracticeSession() {
    if (!currentSession.isActive) return;
    if (!confirm("End this practice session early?")) return;
    const remainingDeckIds = new Set(currentSession.queue.map(entry => entry.deck.id));
    currentSession.decks.forEach(deck => {
        deck.uncompleted = remainingDeckIds.has(deck.id);
    });
    saveData();
    currentSession.isActive = false;
    currentSession.queue = [];
    currentSession.currentCard = null;
    currentSession.currentEntry = null;
    currentSession.deck = null;
    currentSession.decks = [];
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    currentSession.startTime = null;
    if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
    }
    renderPracticeHome();
}

function renderPracticeHome() {
    const container = document.getElementById('practice-container');
    if (!container) return;

    if (app.decks.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; color: var(--text-sub);">
                <h2>Ready to Practice?</h2>
                <p>Select a deck from the Words tab to begin.</p>
                <br>
                <button class="btn-primary" onclick="navTo('words')">Go to Decks</button>
            </div>
        `;
        return;
    }

    const allDeckIds = app.decks.map(deck => deck.id);
    const validSelectedIds = currentSession.selectedDeckIds.filter(id => allDeckIds.includes(id));
    currentSession.selectedDeckIds = validSelectedIds;

    const selectedSet = new Set(currentSession.selectedDeckIds);
    const now = Date.now();
    const dueCountTotal = app.decks.filter(deck => getDueCount(deck, now) > 0).length;
    const inProgressCount = app.decks.filter(deck => deck.uncompleted).length;
    const completedCount = app.decks.filter(deck => !deck.uncompleted && getDueCount(deck, now) === 0).length;
    const filterOptions = [
        { key: 'all', label: `All (${app.decks.length})` },
        { key: 'due', label: `Due (${dueCountTotal})` },
        { key: 'in-progress', label: `In progress (${inProgressCount})` },
        { key: 'completed', label: `Completed (${completedCount})` }
    ];
    const activeFilter = currentSession.practiceFilter || 'all';
    const matchesFilter = (deck) => {
        if (activeFilter === 'due') return getDueCount(deck, now) > 0;
        if (activeFilter === 'in-progress') return deck.uncompleted;
        if (activeFilter === 'completed') return !deck.uncompleted && getDueCount(deck, now) === 0;
        return true;
    };
    const filteredDecks = app.decks.filter(matchesFilter);
    const renderDeckItems = (decks) => decks.map(deck => {
        const dueCount = getDueCount(deck, now);
        return `
        <label class="practice-deck-item">
            <input type="checkbox" class="practice-deck-checkbox" value="${deck.id}" ${selectedSet.has(deck.id) ? 'checked' : ''}>
            <div class="practice-deck-details">
                <div class="practice-deck-name">${deck.name}</div>
                <div class="practice-deck-meta">
                    <span>${deck.cards.length} items</span>
                    <span>${dueCount} due</span>
                    <span>Last practiced: ${formatLastPracticed(deck.lastPracticed)}</span>
                </div>
            </div>
        </label>
    `;
    }).join('');
    const deckItems = renderDeckItems(filteredDecks);

    container.innerHTML = `
        <div class="card practice-selection">
            <h2 style="margin:0;">Choose decks to practice</h2>
            <div class="practice-filters">
                ${filterOptions.map(option => `
                    <button class="practice-filter-btn ${option.key === activeFilter ? 'active' : ''}" data-filter="${option.key}">
                        ${option.label}
                    </button>
                `).join('')}
            </div>
            <label class="practice-deck-item">
                <input type="checkbox" id="practice-select-all">
                <div>
                    <strong>Select all shown</strong>
                </div>
            </label>
            <div class="practice-selection">
                ${deckItems || `<div class="practice-empty">No decks match this filter.</div>`}
            </div>
            <button class="btn-primary" id="practice-start-btn" onclick="startPracticeFromSelection()">Start Practice</button>
        </div>
    `;

    const selectAll = document.getElementById('practice-select-all');
    const deckCheckboxes = Array.from(document.querySelectorAll('.practice-deck-checkbox'));
    const startBtn = document.getElementById('practice-start-btn');
    const deckLabels = Array.from(document.querySelectorAll('.practice-deck-item'));
    const filterButtons = Array.from(document.querySelectorAll('.practice-filter-btn'));

    const syncSelectionState = () => {
        const visibleSelectedCount = deckCheckboxes.filter(cb => cb.checked).length;
        selectAll.checked = deckCheckboxes.length > 0 && visibleSelectedCount === deckCheckboxes.length;
        startBtn.disabled = selectedSet.size === 0;
        deckLabels.forEach(label => {
            const checkbox = label.querySelector('.practice-deck-checkbox');
            if (checkbox) {
                label.classList.toggle('selected', checkbox.checked);
            }
        });
    };

    syncSelectionState();

    selectAll.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        deckCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            if (isChecked) {
                selectedSet.add(cb.value);
            } else {
                selectedSet.delete(cb.value);
            }
        });
        currentSession.selectedDeckIds = Array.from(selectedSet);
        syncSelectionState();
    });

    deckCheckboxes.forEach(cb => {
        cb.addEventListener('change', () => {
            if (cb.checked) {
                selectedSet.add(cb.value);
            } else {
                selectedSet.delete(cb.value);
            }
            currentSession.selectedDeckIds = Array.from(selectedSet);
            syncSelectionState();
        });
    });

    filterButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            currentSession.practiceFilter = btn.dataset.filter || 'all';
            renderPracticeHome();
        });
    });
}

function nextCard() {
    if (currentSession.queue.length === 0) {
        document.getElementById('practice-container').innerHTML = `
            <div style="text-align:center">
                <h2>Session Complete!</h2>
                <p>Great job.</p>
                <button class="btn-primary" onclick="navTo('practice'); renderPracticeHome();">Practice More</button>
            </div>`;
        currentSession.decks.forEach(deck => {
            deck.uncompleted = false;
        });
        saveData();
        currentSession.isActive = false;
        currentSession.currentCard = null;
        currentSession.currentEntry = null;
        currentSession.deck = null;
        return;
    }

    currentSession.currentEntry = currentSession.queue[0];
    currentSession.currentCard = currentSession.currentEntry.card;
    currentSession.deck = currentSession.currentEntry.deck;
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    // Reset timer
    currentSession.startTime = null;
    
    const c = currentSession.currentCard;
    const hasSentence = c.sentence && c.sentence.trim() !== "";
    
    // Hide target word in sentence
    let sentenceDisplay = "";
    if (hasSentence) {
        // Regex to match word case-insensitive
        const regex = new RegExp(`\\b${escapeRegExp(c.word)}\\b`, 'gi');
        sentenceDisplay = c.sentence.replace(regex, "____");
    }

    const html = `
        <div class="practice-header">
            <button class="btn-secondary practice-end" onclick="endPracticeSession()">End Session</button>
        </div>
        <div class="audio-trigger" onclick="playCurrent()">
            <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
        </div>
        ${hasSentence ? `<p style="font-size:1.2rem; color:var(--text-sub); margin-bottom:2rem; text-align:center; padding:0 20px; line-height:1.5;">${sentenceDisplay}</p>` : ''}
        
        <div class="feedback-area" id="feedback"></div>
        
        <input type="text" id="p-input" class="word-input" placeholder="Type word here">
        
        <button id="btn-check" class="btn-primary" style="margin-top:20px" onclick="checkAnswer()">Check</button>
        
        <div id="srs-area" class="srs-controls hidden">
            <button class="srs-btn srs-again" onclick="rateCard(1)">Again</button>
            <button class="srs-btn srs-hard" onclick="rateCard(2)">Hard</button>
            <button class="srs-btn srs-good" onclick="rateCard(3)">Good</button>
            <button class="srs-btn srs-easy" onclick="rateCard(4)">Easy</button>
        </div>
    `;
    
    document.getElementById('practice-container').innerHTML = html;
    
    const input = document.getElementById('p-input');
    applySuggestionSettingToInput(input);
    input.focus();
    
    // Set timer if start on show
    if (app.settings.timerStart === 'show') {
        currentSession.startTime = Date.now();
    }
    // Autoplay audio if enabled
    if (app.settings.autoplay) {
        setTimeout(() => {
            playCurrent();
        }, 300);
    }

    // Keyboard support
    input.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
        if (currentSession.isAnswered) return;
        e.preventDefault();
        e.stopPropagation();
        checkAnswer();
    });
}

function applySuggestionSettingToInput(input) {
    if (!input) return;
    const shouldBlock = Boolean(app.settings.blockSuggestions);
    if (shouldBlock) {
        input.setAttribute('autocomplete', 'off');
        input.setAttribute('autocorrect', 'off');
        input.setAttribute('autocapitalize', 'off');
        input.setAttribute('spellcheck', 'false');
        input.setAttribute('aria-autocomplete', 'none');
    } else {
        input.removeAttribute('autocomplete');
        input.removeAttribute('autocorrect');
        input.removeAttribute('autocapitalize');
        input.removeAttribute('spellcheck');
        input.removeAttribute('aria-autocomplete');
    }
}

function playCurrent() {
    if (!currentSession.currentCard) return;
    const card = currentSession.currentCard;
    // Play custom audio if URL exists
    if (card.audioUrl) {
        try {
            const audio = new Audio(card.audioUrl);
            const btn = document.querySelector('.audio-trigger');
            if (btn) btn.classList.add('playing');
            audio.onplay = () => {
                if (app.settings.timerStart === 'audio') {
                    currentSession.startTime = Date.now();
                }
            };
            audio.onended = () => { if (btn) btn.classList.remove('playing'); };
            audio.onerror = () => {
                if (btn) btn.classList.remove('playing');
                // fallback to TTS if audio fails
                speakCard();
            };
            audio.play().catch((err) => {
                if (btn) btn.classList.remove('playing');
                speakCard();
            });
            return;
        } catch(e) {
            // fallback to speech synthesis
            speakCard();
            return;
        }
    }
    // Fallback to TTS
    speakCard();
    function speakCard() {
        // If timing starts on audio, start timer now
        if (app.settings.timerStart === 'audio') {
            currentSession.startTime = Date.now();
        }
        const lang = currentSession.deck ? currentSession.deck.lang : 'en-US';
        // If card has a sentence, speak word then sentence for context
        if (card.sentence && card.sentence.trim() !== '') {
            const phrase = `${card.word}. ${card.sentence}`;
            speak(phrase, lang);
        } else {
            speak(card.word, lang);
        }
    }
}

function checkAnswer() {
    const input = document.getElementById('p-input');
    const userRaw = input.value.trim();
    const userValLower = userRaw.toLowerCase();
    const correctRaw = currentSession.currentCard.word;
    const correctLower = correctRaw.toLowerCase();
    // Determine correctness based on strictness
    let isCorrect = false;
    if (app.settings.strictness === 'strict') {
        isCorrect = userRaw === correctRaw;
    } else {
        isCorrect = userValLower === correctLower;
    }
    currentSession.isAnswered = true;
    currentSession.lastAnswerCorrect = isCorrect;
    document.getElementById('btn-check').classList.add('hidden');
    document.getElementById('srs-area').classList.remove('hidden');
    input.disabled = true;
    const feedback = document.getElementById('feedback');
    // Update performance statistics
    const card = currentSession.currentCard;
    const now = Date.now();
    let elapsed = 0;
    if (currentSession.startTime) {
        elapsed = (now - currentSession.startTime) / 1000;
    }
    // Compute average time (running average)
    const prevAttempts = (card.correctCount || 0) + (card.incorrectCount || 0);
    if (prevAttempts === 0) {
        card.avgTime = elapsed;
    } else {
        card.avgTime = ((card.avgTime || 0) * prevAttempts + elapsed) / (prevAttempts + 1);
    }
    if (isCorrect) {
        card.correctCount = (card.correctCount || 0) + 1;
    } else {
        card.incorrectCount = (card.incorrectCount || 0) + 1;
    }
    saveData();
    // Provide feedback
    if (isCorrect) {
        input.style.color = 'var(--success)';
        feedback.innerHTML = `<span style="color:var(--success); font-weight:bold;">Correct!</span>`;
    } else {
        input.style.color = 'var(--error)';
        // Show Diff
        feedback.innerHTML = `<div class="diff-display">
            <span class="diff-wrong">${input.value}</span>
            <span class="diff-correct">${currentSession.currentCard.word}</span>
        </div>`;
    }
}

function rateCard(quality) {
    const card = currentSession.currentCard;
    const entry = currentSession.currentEntry;
    
    // Simple SRS Logic
    if (quality < 3) {
        card.interval = 1;
        card.ease = Math.max(1.3, card.ease - 0.2);
    } else {
        if (card.interval === 0) card.interval = 1;
        else if (card.interval === 1) card.interval = 3;
        else card.interval = Math.ceil(card.interval * card.ease);
        
        card.ease = card.ease + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        if (card.ease < 1.3) card.ease = 1.3;
    }

    // Set Due Date
    const DAY_MS = 86400000;
    card.due = Date.now() + (quality < 3 ? 0 : card.interval * DAY_MS);

    if (entry && entry.deck) {
        entry.deck.lastPracticed = Date.now();
    }
    saveData();
    
    currentSession.queue.shift(); // Remove current
    if (quality < 3 || currentSession.lastAnswerCorrect === false || quality === 1) {
        currentSession.queue.unshift(entry); // Re-queue immediately
    }
    
    nextCard();
}

// --- DECK MANAGEMENT ---
function renderDeckList() {
    const list = document.getElementById('deck-list');
    list.innerHTML = '';
    
    if (app.decks.length === 0) {
        list.innerHTML = `<div style="text-align:center; padding:2rem; color:var(--text-sub);">
            No decks yet.<br>Click "+ New" to create one.
        </div>`;
        return;
    }

    app.decks.forEach(deck => {
        const dueCount = getDueCount(deck);
        const div = document.createElement('div');
        div.className = 'deck-item';
        div.innerHTML = `
            <div class="deck-info">
                <h3>${deck.name}</h3>
                <small>${deck.lang} • ${deck.cards.length} cards • ${dueCount} due</small>
            </div>
            <div style="display:flex; gap:8px;">
                <button class="btn-secondary" onclick="openDeckActions('${deck.id}')">Edit</button>
                <button class="btn-primary" style="padding: 10px 20px;" onclick="startPractice(['${deck.id}'])">Play</button>
            </div>
        `;
        list.appendChild(div);
    });
}

// --- PROGRESS RENDERING ---
function renderProgress() {
    const overviewEl = document.getElementById('progress-overview');
    const detailsEl = document.getElementById('progress-details');
    if (!overviewEl || !detailsEl) return;
    overviewEl.innerHTML = '';
    detailsEl.innerHTML = '';
    if (app.decks.length === 0) {
        overviewEl.innerHTML = '<div style="padding:1rem; color:var(--text-sub); text-align:center;">No data yet.</div>';
        return;
    }
    let total = 0;
    let newWords = 0;
    let learning = 0;
    let mastered = 0;
    let dueTotal = 0;
    let sumTime = 0;
    let countTime = 0;
    const troubleList = [];
    const now = Date.now();
    app.decks.forEach(deck => {
        deck.cards.forEach(card => {
            total++;
            if (card.due <= now) {
                dueTotal++;
            }
            if (card.interval === 0) {
                newWords++;
            } else if (card.interval > 15) {
                mastered++;
            } else {
                learning++;
            }
            if (card.avgTime && card.avgTime > 0) {
                sumTime += card.avgTime;
                countTime++;
            }
            troubleList.push({
                word: card.word,
                deck: deck.name,
                incorrect: card.incorrectCount || 0,
                avgTime: card.avgTime || 0
            });
        });
    });
    const avgTime = countTime > 0 ? (sumTime / countTime).toFixed(1) : 'N/A';
    // Overview table
    let overviewHTML = '<table style="width:100%; border-collapse:collapse; font-size:0.95rem;">';
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Total words</th><td style="padding:6px 4px; text-align:right;">${total}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Due</th><td style="padding:6px 4px; text-align:right;">${dueTotal}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">New</th><td style="padding:6px 4px; text-align:right;">${newWords}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Learning</th><td style="padding:6px 4px; text-align:right;">${learning}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Mastered</th><td style="padding:6px 4px; text-align:right;">${mastered}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Average response time (s)</th><td style="padding:6px 4px; text-align:right;">${avgTime}</td></tr>`;
    overviewHTML += '</table>';
    overviewEl.innerHTML = overviewHTML;
    // Trouble words
    troubleList.sort((a,b) => {
        if (b.incorrect !== a.incorrect) return b.incorrect - a.incorrect;
        return b.avgTime - a.avgTime;
    });
    const topTrouble = troubleList.filter(t => t.incorrect > 0 || t.avgTime > 0).slice(0,10);
    if (topTrouble.length > 0) {
        let detailsHTML = '<h3 style="margin-top:0;">Trouble Words</h3>';
        detailsHTML += '<table style="width:100%; border-collapse:collapse; font-size:0.9rem;">';
        detailsHTML += '<tr><th style="text-align:left; padding:4px;">Word</th><th style="text-align:left; padding:4px;">Deck</th><th style="text-align:right; padding:4px;">Errors</th><th style="text-align:right; padding:4px;">Avg time (s)</th></tr>';
        topTrouble.forEach(item => {
            detailsHTML += `<tr><td style="padding:4px;">${item.word}</td><td style="padding:4px;">${item.deck}</td><td style="padding:4px; text-align:right;">${item.incorrect}</td><td style="padding:4px; text-align:right;">${item.avgTime.toFixed ? item.avgTime.toFixed(1) : item.avgTime}</td></tr>`;
        });
        detailsHTML += '</table>';
        detailsEl.innerHTML = detailsHTML;
    } else {
        detailsEl.innerHTML = '<div style="padding:1rem; color:var(--text-sub);">No trouble words yet. Keep practicing!</div>';
    }
}

// Modal Logic
let activeDeckIdForEdit = null;
function openDeckModal() {
    document.getElementById('deck-modal').classList.add('open');
    document.getElementById('new-deck-name').value = '';
    showDeckPanel('create');
}
function closeDeckModal() {
    document.getElementById('deck-modal').classList.remove('open');
}
function showDeckPanel(panel) {
    const createToggle = document.getElementById('deck-toggle-create');
    const importToggle = document.getElementById('deck-toggle-import');
    const createPanel = document.getElementById('deck-panel-create');
    const importPanel = document.getElementById('deck-panel-import');
    if (panel === 'import') {
        createToggle.classList.remove('active');
        importToggle.classList.add('active');
        createPanel.classList.add('hidden');
        importPanel.classList.remove('hidden');
    } else {
        importToggle.classList.remove('active');
        createToggle.classList.add('active');
        importPanel.classList.add('hidden');
        createPanel.classList.remove('hidden');
    }
}
function triggerDeckImport() {
    document.getElementById('import-deck-file').click();
}
function focusDeckPaste() {
    const textArea = document.getElementById('import-deck-json');
    if (!textArea) return;
    textArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
    textArea.focus();
}
function importDeckFromPaste() {
    const textArea = document.getElementById('import-deck-json');
    if (!textArea) return;
    const raw = textArea.value.trim();
    if (!raw) {
        alert("Paste deck JSON first.");
        return;
    }
    try {
        const data = JSON.parse(raw);
        const decks = normalizeImportedDecks(data);
        if (!decks.length) {
            alert("Invalid deck JSON");
            return;
        }
        app.decks.push(...decks);
        saveData();
        renderDeckList();
        textArea.value = '';
        closeDeckModal();
    } catch (err) {
        alert("Invalid deck JSON");
    }
}
function saveDeck() {
    const name = document.getElementById('new-deck-name').value;
    const lang = document.getElementById('new-deck-lang').value;
    if (!name) return;
    
    app.decks.push({
        id: generateDeckId(),
        name,
        lang,
        cards: [],
        uncompleted: false,
        lastPracticed: null
    });
    saveData();
    closeDeckModal();
    renderDeckList();
}

function manageCards(deckId) {
    activeDeckIdForEdit = deckId;
    document.getElementById('cards-modal').classList.add('open');
    renderCardList();
}
function closeCardsModal() {
    document.getElementById('cards-modal').classList.remove('open');
}

function openDeckActions(deckId) {
    activeDeckIdForEdit = deckId;
    const deck = app.decks.find(d => d.id === deckId);
    document.getElementById('deck-actions-title').textContent = deck ? deck.name : 'Deck Actions';
    document.getElementById('deck-actions-modal').classList.add('open');
}

function closeDeckActionsModal() {
    document.getElementById('deck-actions-modal').classList.remove('open');
}

function openDeckEditor() {
    closeDeckActionsModal();
    if (activeDeckIdForEdit) manageCards(activeDeckIdForEdit);
}

function openDeckStats() {
    closeDeckActionsModal();
    if (activeDeckIdForEdit) renderDeckProgress(activeDeckIdForEdit);
}

function openDeckMetaEditor() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    document.getElementById('edit-deck-name').value = deck.name || '';
    document.getElementById('edit-deck-lang').value = deck.lang || 'en-US';
    closeDeckActionsModal();
    document.getElementById('deck-meta-modal').classList.add('open');
}

function closeDeckMetaModal() {
    document.getElementById('deck-meta-modal').classList.remove('open');
}

function saveDeckMeta() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    const nameInput = document.getElementById('edit-deck-name');
    const langSelect = document.getElementById('edit-deck-lang');
    const newName = nameInput.value.trim();
    if (!newName) {
        alert("Deck name can't be empty.");
        return;
    }
    deck.name = newName;
    deck.lang = langSelect.value;
    saveData();
    closeDeckMetaModal();
    renderDeckList();
    renderPracticeHome();
    renderProgress();
    if (document.getElementById('view-deck-progress').classList.contains('active')) {
        renderDeckProgress(deck.id);
    }
}

function clearDeckCompletion(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    if (deck) deck.uncompleted = false;
    if (Array.isArray(currentSession.decks)) {
        currentSession.decks.forEach(sessionDeck => {
            if (sessionDeck.id === deckId) sessionDeck.uncompleted = false;
        });
    }
    if (Array.isArray(currentSession.queue)) {
        currentSession.queue.forEach(entry => {
            if (entry.deck && entry.deck.id === deckId) {
                entry.deck.uncompleted = false;
            }
        });
    }
}

function resetDeckStats() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    if (!confirm(`Reset stats for "${deck.name}"? This will mark all words as new.`)) return;
    deck.cards.forEach(card => {
        card.due = 0;
        card.interval = 0;
        card.ease = 2.5;
        card.correctCount = 0;
        card.incorrectCount = 0;
        card.avgTime = 0;
    });
    clearDeckCompletion(deck.id);
    saveData();
    renderDeckProgress(deck.id);
    renderProgress();
    if (!currentSession.isActive && document.getElementById('view-practice').classList.contains('active')) {
        renderPracticeHome();
    }
}

function exportDeck() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    const str = JSON.stringify(deck, null, 2);
    const blob = new Blob([str], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const safeName = deck.name ? deck.name.replace(/[^a-z0-9-_]+/gi, '_') : 'deck';
    a.href = url;
    a.download = `${safeName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function deleteDeck() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    if (!confirm(`Delete "${deck.name}"? This cannot be undone.`)) return;
    app.decks = app.decks.filter(d => d.id !== activeDeckIdForEdit);
    currentSession.selectedDeckIds = currentSession.selectedDeckIds.filter(id => id !== activeDeckIdForEdit);
    saveData();
    closeDeckActionsModal();
    renderDeckList();
    if (currentSession.deck && currentSession.deck.id === activeDeckIdForEdit) {
        currentSession.deck = null;
        currentSession.queue = [];
    }
    activeDeckIdForEdit = null;
}

function renderCardList() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    const container = document.getElementById('cards-list-content');
    container.innerHTML = '';
    
    if(deck.cards.length === 0) {
        container.innerHTML = '<div style="text-align:center; color:#999; padding:20px;">No cards yet</div>';
        return;
    }

    deck.cards.slice().reverse().forEach((card, index) => {
        const div = document.createElement('div');
        div.style = "display:flex; justify-content:space-between; align-items:center; padding: 12px 0; border-bottom:1px solid #f3f4f6;";
        const realIndex = deck.cards.length - 1 - index;
        div.innerHTML = `
            <div>
                <strong style="font-size:1.1rem;">${card.word}</strong>
                ${card.sentence ? `<div style="font-size:0.85rem; color:#666; margin-top:4px;">${card.sentence}</div>` : ''}
            </div>
            <button class="btn-icon" style="background:#fee2e2; color:var(--error); width:32px; height:32px;" onclick="deleteCard(${realIndex})">✕</button>
        `;
        container.appendChild(div);
    });
}

function addCardToDeck() {
    const w = document.getElementById('new-card-word');
    const s = document.getElementById('new-card-sentence');
    const a = document.getElementById('new-card-audio');
    if (!w.value) return;
    
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    deck.cards.push({
        word: w.value.trim(),
        sentence: s.value.trim(),
        audioUrl: a.value.trim() || '',
        due: 0,
        interval: 0,
        ease: 2.5,
        correctCount: 0,
        incorrectCount: 0,
        avgTime: 0
    });
    w.value = '';
    s.value = '';
    a.value = '';
    w.focus();
    saveData();
    renderCardList();
    renderDeckList();
}

function handlePracticeKeydown(event) {
    if (event.key !== "Enter") return;
    if (!currentSession.isActive || !currentSession.currentCard) return;
    if (!currentSession.isAnswered) return;
    event.preventDefault();
    const quality = currentSession.lastAnswerCorrect ? 3 : 2;
    rateCard(quality);
}

function initCardInputListeners() {
    const inputs = [
        document.getElementById('new-card-word'),
        document.getElementById('new-card-sentence'),
        document.getElementById('new-card-audio')
    ].filter(Boolean);
    inputs.forEach(input => {
        input.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter') return;
            event.preventDefault();
            addCardToDeck();
        });
    });
}

function deleteCard(index) {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    deck.cards.splice(index, 1);
    saveData();
    renderCardList();
    renderDeckList();
}

function renderDeckProgress(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    const overviewEl = document.getElementById('deck-progress-overview');
    const detailsEl = document.getElementById('deck-progress-details');
    const titleEl = document.getElementById('deck-progress-title');
    if (!deck || !overviewEl || !detailsEl || !titleEl) return;
    activeDeckIdForEdit = deckId;
    titleEl.textContent = `${deck.name} Progress`;
    overviewEl.innerHTML = '';
    detailsEl.innerHTML = '';
    if (deck.cards.length === 0) {
        overviewEl.innerHTML = '<div style="padding:1rem; color:var(--text-sub); text-align:center;">No cards yet.</div>';
        navTo('deck-progress');
        return;
    }
    let total = 0;
    let newWords = 0;
    let learning = 0;
    let mastered = 0;
    let dueTotal = 0;
    let sumTime = 0;
    let countTime = 0;
    const troubleList = [];
    const now = Date.now();
    deck.cards.forEach(card => {
        total++;
        if (card.due <= now) {
            dueTotal++;
        }
        if (card.interval === 0) {
            newWords++;
        } else if (card.interval > 15) {
            mastered++;
        } else {
            learning++;
        }
        if (card.avgTime && card.avgTime > 0) {
            sumTime += card.avgTime;
            countTime++;
        }
        troubleList.push({
            word: card.word,
            deck: deck.name,
            incorrect: card.incorrectCount || 0,
            avgTime: card.avgTime || 0
        });
    });
    const avgTime = countTime > 0 ? (sumTime / countTime).toFixed(1) : 'N/A';
    let overviewHTML = '<table style="width:100%; border-collapse:collapse; font-size:0.95rem;">';
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Total words</th><td style="padding:6px 4px; text-align:right;">${total}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Due</th><td style="padding:6px 4px; text-align:right;">${dueTotal}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">New</th><td style="padding:6px 4px; text-align:right;">${newWords}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Learning</th><td style="padding:6px 4px; text-align:right;">${learning}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Mastered</th><td style="padding:6px 4px; text-align:right;">${mastered}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:6px 4px;">Average response time (s)</th><td style="padding:6px 4px; text-align:right;">${avgTime}</td></tr>`;
    overviewHTML += '</table>';
    overviewEl.innerHTML = overviewHTML;
    troubleList.sort((a,b) => {
        if (b.incorrect !== a.incorrect) return b.incorrect - a.incorrect;
        return b.avgTime - a.avgTime;
    });
    const topTrouble = troubleList.filter(t => t.incorrect > 0 || t.avgTime > 0).slice(0,10);
    if (topTrouble.length > 0) {
        let detailsHTML = '<h3 style="margin-top:0;">Trouble Words</h3>';
        detailsHTML += '<table style="width:100%; border-collapse:collapse; font-size:0.9rem;">';
        detailsHTML += '<tr><th style="text-align:left; padding:4px;">Word</th><th style="text-align:left; padding:4px;">Errors</th><th style="text-align:right; padding:4px;">Avg time (s)</th></tr>';
        topTrouble.forEach(item => {
            detailsHTML += `<tr><td style="padding:4px;">${item.word}</td><td style="padding:4px;">${item.incorrect}</td><td style="padding:4px; text-align:right;">${item.avgTime.toFixed ? item.avgTime.toFixed(1) : item.avgTime}</td></tr>`;
        });
        detailsHTML += '</table>';
        detailsEl.innerHTML = detailsHTML;
    } else {
        detailsEl.innerHTML = '<div style="padding:1rem; color:var(--text-sub);">No trouble words yet. Keep practicing!</div>';
    }
    navTo('deck-progress');
}

// --- UTILS & INIT ---
function generateDeckId() {
    return `deck-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function getDueCount(deck, now = Date.now()) {
    if (!deck || !Array.isArray(deck.cards)) return 0;
    return deck.cards.filter(card => card.due <= now).length;
}

function formatLastPracticed(timestamp) {
    if (!timestamp) return 'Never';
    const date = new Date(timestamp);
    if (Number.isNaN(date.getTime())) return 'Never';
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
}

function normalizeImportedDecks(raw) {
    let decks = [];
    if (Array.isArray(raw)) {
        decks = raw;
    } else if (raw && Array.isArray(raw.decks)) {
        decks = raw.decks;
    } else if (raw && raw.name && Array.isArray(raw.cards)) {
        decks = [raw];
    }
    return decks.map((deck) => {
        const existingId = deck.id && !app.decks.some(d => d.id === deck.id);
        const normalizedCards = Array.isArray(deck.cards) ? deck.cards.map(card => ({
            word: String(card.word || '').trim(),
            sentence: card.sentence ? String(card.sentence) : '',
            audioUrl: card.audioUrl ? String(card.audioUrl) : '',
            due: Number(card.due) || 0,
            interval: Number(card.interval) || 0,
            ease: typeof card.ease === 'number' ? card.ease : 2.5,
            correctCount: Number(card.correctCount) || 0,
            incorrectCount: Number(card.incorrectCount) || 0,
            avgTime: Number(card.avgTime) || 0
        })).filter(card => card.word) : [];
        return {
            id: existingId ? deck.id : generateDeckId(),
            name: deck.name ? String(deck.name) : 'Imported Deck',
            lang: deck.lang ? String(deck.lang) : 'en-US',
            cards: normalizedCards,
            uncompleted: Boolean(deck.uncompleted),
            lastPracticed: deck.lastPracticed ? Number(deck.lastPracticed) : null
        };
    });
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function initSettingsListeners() {
    const speed = document.getElementById('setting-speed');
    speed.value = app.settings.speed || 1.0;
    document.getElementById('speed-val').textContent = speed.value;

    speed.addEventListener('input', (e) => {
        app.settings.speed = e.target.value;
        document.getElementById('speed-val').textContent = e.target.value;
        saveData();
    });

    const voiceModeEl = document.getElementById('setting-voice-mode');
    if (voiceModeEl) {
        voiceModeEl.value = app.settings.voiceMode || 'auto';
        updateVoiceModeUI();
        voiceModeEl.addEventListener('change', (e) => {
            app.settings.voiceMode = e.target.value;
            updateVoiceModeUI();
            saveData();
        });
    }

    document.getElementById('setting-voice').addEventListener('change', (e) => {
        app.settings.voiceURI = e.target.value;
        saveData();
    });

    // Autoplay toggle
    const autoplayEl = document.getElementById('setting-autoplay');
    if (autoplayEl) {
        autoplayEl.checked = Boolean(app.settings.autoplay);
        autoplayEl.addEventListener('change', (e) => {
            app.settings.autoplay = e.target.checked;
            saveData();
        });
    }
    const blockSuggestionsEl = document.getElementById('setting-block-suggestions');
    if (blockSuggestionsEl) {
        blockSuggestionsEl.checked = Boolean(app.settings.blockSuggestions);
        blockSuggestionsEl.addEventListener('change', (e) => {
            app.settings.blockSuggestions = e.target.checked;
            applySuggestionSettingToInput(document.getElementById('p-input'));
            saveData();
        });
    }
    // Strictness select
    const strictEl = document.getElementById('setting-strictness');
    if (strictEl) {
        strictEl.value = app.settings.strictness || 'strict';
        strictEl.addEventListener('change', (e) => {
            app.settings.strictness = e.target.value;
            saveData();
        });
    }
    // Timer start select
    const timerEl = document.getElementById('setting-timerStart');
    if (timerEl) {
        timerEl.value = app.settings.timerStart || 'audio';
        timerEl.addEventListener('change', (e) => {
            app.settings.timerStart = e.target.value;
            saveData();
        });
    }
}

function exportData() {
    const str = JSON.stringify(app);
    const blob = new Blob([str], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "spellmaster_backup.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

document.getElementById('import-file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            if (data.decks) {
                app = data;
                saveData();
                location.reload();
            }
        } catch(err) { alert("Invalid file"); }
    };
    reader.readAsText(file);
});

document.getElementById('import-deck-file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = JSON.parse(event.target.result);
            const decks = normalizeImportedDecks(data);
            if (!decks.length) {
                alert("Invalid deck file");
                return;
            }
            app.decks.push(...decks);
            saveData();
            renderDeckList();
            closeDeckModal();
        } catch (err) {
            alert("Invalid deck file");
        }
    };
    reader.readAsText(file);
    e.target.value = '';
});

function resetApp() {
    if(confirm("Delete all data? This cannot be undone.")) {
        localStorage.removeItem('spellmaster_data_v2');
        location.reload();
    }
}

// --- BOOTSTRAP ---
initAudio();
loadData();
initCardInputListeners();
document.addEventListener('keydown', handlePracticeKeydown);

// Add some demo data if empty
if(app.decks.length === 0) {
    app.decks.push({
        id: "demo1", name: "English Demo", lang: "en-US",
        uncompleted: false,
        cards: [
            // Provide a variety of example words to allow immediate practice without configuration.
            {word: "necessary", sentence: "It is necessary to sleep well.", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "queue", sentence: "Wait in the queue.", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "apple", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "banana", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "books", sentence: "I forgot my books at home", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "school", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0}
        ]
    });
    saveData();
    renderDeckList();
}

</script>
</body>
</html>
