<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SpellMaster</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
    /* --- VARIABLES & RESET --- */
    :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --accent: #f59e0b;
        --accent-soft: #fef3c7;
        --bg-body: #eef2ff;
        --bg-card: #ffffff;
        --bg-card-soft: #f8f7ff;
        --text-main: #1f2937;
        --text-sub: #6b7280;
        --success: #10b981;
        --error: #ef4444;
        --nav-height: 72px;
        --radius: 16px;
        --radius-sm: 12px;
        --space-1: 8px;
        --space-2: 16px;
        --space-3: 24px;
        --space-4: 32px;
        --space-5: 40px;
        --font-h1: 1.75rem;
        --font-h2: 1.35rem;
        --font-body: 1rem;
        --font-small: 0.85rem;
        /* additional neutral colour used for toggles */
        --neutral-200: #e5e7eb;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
        margin: 0;
        font-family: "Fredoka", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background: radial-gradient(circle at top, #fef9f4 0%, var(--bg-body) 45%);
        color: var(--text-main);
        font-size: var(--font-body);
        line-height: 1.6;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    h1, h2, h3 {
        margin: 0 0 var(--space-2);
        line-height: 1.2;
        font-family: "Fredoka", "Segoe UI", sans-serif;
        letter-spacing: 0.01em;
    }
    h1 { font-size: var(--font-h1); }
    h2 { font-size: var(--font-h2); }
    h3 { font-size: 1.05rem; }
    p { margin: 0 0 var(--space-2); }
    small, .text-small { font-size: var(--font-small); }

    .settings-toggle {
        width: 100%;
        border: 1px solid rgba(99, 102, 241, 0.2);
        background: #ffffff;
        color: var(--text-main);
        border-radius: 12px;
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        margin-top: var(--space-2);
        box-shadow: 0 8px 16px -12px rgba(15, 23, 42, 0.4);
    }

    .settings-toggle::after {
        content: '‚ñæ';
        font-size: 0.9rem;
        color: var(--text-sub);
        transition: transform 0.2s ease;
    }

    .settings-toggle.active::after {
        transform: rotate(180deg);
    }

    .settings-panel {
        display: none;
        padding: var(--space-2);
        border-radius: 12px;
        background: var(--bg-card-soft);
        margin-top: var(--space-1);
        border: 1px solid rgba(99, 102, 241, 0.12);
    }

    .settings-panel.open {
        display: block;
    }

    /* --- LAYOUT --- */
    header {
        padding: var(--space-2);
        background: linear-gradient(135deg, #ffffff 0%, #eef2ff 60%, #ffe5d0 100%);
        text-align: left;
        font-weight: 800;
        font-size: var(--font-h2);
        color: var(--primary);
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
        z-index: 10;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .header-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-2);
    }

    .app-title {
        font-size: var(--font-h2);
        font-weight: 800;
        color: var(--primary);
    }

    .app-tagline {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--text-sub);
        letter-spacing: 0.02em;
    }

    .language-filter {
        position: relative;
        display: inline-flex;
        align-items: center;
    }

    .language-filter-btn {
        border: 1px solid rgba(99, 102, 241, 0.2);
        background: #ffffff;
        color: var(--text-main);
        border-radius: 999px;
        padding: 6px 10px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 0.85rem;
        cursor: pointer;
        box-shadow: 0 6px 14px -10px rgba(15, 23, 42, 0.4);
    }

    .language-filter-btn span.flag {
        font-size: 1.1rem;
    }

    .language-filter-btn svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
        opacity: 0.7;
    }

    .language-filter-menu {
        position: absolute;
        right: 0;
        top: calc(100% + 6px);
        background: #ffffff;
        border-radius: 14px;
        border: 1px solid rgba(99, 102, 241, 0.2);
        box-shadow: 0 12px 28px -18px rgba(15, 23, 42, 0.5);
        min-width: 180px;
        padding: 8px;
        display: none;
        z-index: 50;
    }

    .language-filter-menu.open {
        display: grid;
        gap: 4px;
    }

    .language-filter-option {
        border: none;
        background: transparent;
        text-align: left;
        padding: 8px 10px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-family: inherit;
        font-size: 0.9rem;
        color: var(--text-main);
    }

    .language-filter-option.active {
        background: var(--bg-card-soft);
        color: var(--primary-dark);
        font-weight: 600;
    }

    .language-filter-option:hover {
        background: rgba(99, 102, 241, 0.12);
    }

    main {
        flex: 1;
        overflow-y: auto;
        padding: var(--space-3);
        padding-bottom: calc(var(--nav-height) + 120px + env(safe-area-inset-bottom));
        max-width: 600px;
        width: 100%;
        margin: 0 auto;
        scroll-padding-bottom: calc(var(--nav-height) + 120px + env(safe-area-inset-bottom));
    }

    .view { display: none; min-height: 100%; }
    .view.active { display: block; animation: fadeIn 0.3s ease; }

    /* --- NAVIGATION --- */
    nav {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: var(--nav-height);
        background: var(--bg-card);
        border-top: 1px solid rgba(148, 163, 184, 0.2);
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 20;
        padding-bottom: env(safe-area-inset-bottom);
    }

    nav button {
        background: none;
        border: none;
        color: var(--text-sub);
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: var(--font-small);
        width: 100%;
        height: 100%;
        justify-content: center;
        cursor: pointer;
        gap: 2px;
    }

    nav button svg { width: 24px; height: 24px; margin-bottom: 4px; fill: currentColor; overflow: visible; }
    nav button.active {
        color: var(--primary);
        background: #eef2ff;
        border-radius: 16px;
        position: relative;
    }
    nav button.active::after {
        content: "";
        position: absolute;
        top: 6px;
        right: 22px;
        width: 10px;
        height: 10px;
        background: var(--accent);
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    /* --- COMPONENTS --- */
    .card {
        background: linear-gradient(180deg, #ffffff 0%, var(--bg-card-soft) 100%);
        border-radius: var(--radius);
        padding: var(--space-3);
        box-shadow: 0 12px 26px -20px rgba(15, 23, 42, 0.4);
        border: 1px solid rgba(99, 102, 241, 0.15);
        margin-bottom: var(--space-2);
        transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 24px -16px rgba(15, 23, 42, 0.25);
    }

    .progress-metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: var(--space-2);
    }

    .progress-metric {
        background: #ffffff;
        border-radius: var(--radius-sm);
        padding: var(--space-2);
        border: 1px solid rgba(99, 102, 241, 0.2);
    }

    .progress-metric-label {
        color: var(--text-sub);
        font-size: var(--font-small);
        margin-bottom: 4px;
    }

    .progress-metric-value {
        font-size: 1.4rem;
        font-weight: 700;
        color: var(--primary-dark);
    }

    .progress-trouble-list {
        display: flex;
        flex-direction: column;
        gap: var(--space-1);
        margin-bottom: var(--space-2);
    }

    .progress-trouble-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-2);
        padding: var(--space-1) 0;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .progress-trouble-item:last-child {
        border-bottom: none;
    }

    button {
        cursor: pointer;
        border: none;
        font-family: inherit;
        font-weight: 600;
        transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, color 0.12s ease, border-color 0.12s ease;
        outline: none;
    }
    button:active { transform: scale(0.98); }

    .btn-primary {
        background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        color: white;
        padding: calc(var(--space-2) + 2px);
        border-radius: var(--radius-sm);
        width: 100%;
        font-size: 1.05rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-1);
        box-shadow: 0 16px 26px -14px rgba(99, 102, 241, 0.7);
        position: relative;
        overflow: hidden;
    }
    .btn-primary::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(120deg, rgba(255,255,255,0.35), rgba(255,255,255,0));
        opacity: 0.6;
        pointer-events: none;
    }
    .btn-primary:hover {
        box-shadow: 0 16px 24px -14px rgba(99, 102, 241, 0.7);
        transform: translateY(-1px);
    }
    .btn-primary:disabled {
        background: #d1d5db;
        color: #6b7280;
        box-shadow: none;
        cursor: not-allowed;
    }
    
    .btn-secondary {
        background: #ffffff;
        color: var(--primary-dark);
        border: 1px solid rgba(99, 102, 241, 0.35);
        padding: calc(var(--space-2) - 4px) var(--space-2);
        border-radius: var(--radius-sm);
        font-weight: 600;
        box-shadow: 0 8px 18px -14px rgba(15, 23, 42, 0.25);
    }
    .btn-secondary:hover {
        border-color: var(--primary);
        background: var(--accent-soft);
        box-shadow: 0 12px 18px -14px rgba(15, 23, 42, 0.3);
    }
    
    .btn-icon {
        background: #ffffff;
        padding: 8px;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(148, 163, 184, 0.35);
    }

    input, select, textarea {
        width: 100%;
        padding: var(--space-2);
        border: 2px solid #e5e7eb;
        border-radius: var(--radius-sm);
        font-size: 1rem;
        background: #f9fafb;
        margin-bottom: var(--space-2);
        -webkit-appearance: none; /* Fix for iOS input styles */
    }
    input:focus { border-color: var(--primary); outline: none; background: #fff; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); }

    /* --- PRACTICE SCREEN --- */
    .practice-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 80%;
    }

    .audio-stack {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--space-1);
        margin-bottom: var(--space-3);
    }
    .audio-trigger {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 18px 36px rgba(99, 102, 241, 0.4);
        margin-bottom: 0;
        transition: transform 0.16s ease, box-shadow 0.16s ease;
        cursor: pointer;
        position: relative;
    }
    .audio-trigger::after {
        content: "";
        position: absolute;
        inset: 10px;
        border-radius: 50%;
        border: 2px dashed rgba(255, 255, 255, 0.4);
    }
    .audio-trigger:active { transform: scale(0.95); }
    .audio-trigger.playing { animation: pulse 1.5s infinite; }
    .audio-trigger svg { width: 50px; height: 50px; fill: white; }
    .audio-trigger.disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
        pointer-events: none;
    }
    .audio-label {
        margin-top: var(--space-1);
        font-size: var(--font-small);
        font-weight: 700;
        color: var(--text-sub);
        letter-spacing: 0.02em;
    }
    .dictation-repeat-status {
        font-size: 0.85rem;
        color: var(--text-sub);
        text-align: center;
        margin-bottom: var(--space-3);
    }
    .dictation-score {
        font-size: 1.05rem;
        font-weight: 700;
        color: var(--primary-dark);
        margin-top: var(--space-2);
    }
    .dictation-error-list {
        margin-top: var(--space-1);
        padding: 0;
        list-style: none;
        display: grid;
        gap: 4px;
        font-size: 0.95rem;
    }
    .dictation-error-list li {
        display: flex;
        justify-content: space-between;
        padding: 6px 10px;
        border-radius: 10px;
        background: rgba(99, 102, 241, 0.08);
        color: var(--text-main);
    }

    .word-input {
        font-size: 2rem;
        text-align: center;
        border: none;
        border-bottom: 3px solid #e5e7eb;
        border-radius: 0;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0) 0%, rgba(238, 242, 255, 0.6) 100%);
        color: var(--primary);
        letter-spacing: 1px;
        font-weight: bold;
        margin-bottom: var(--space-2);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .word-input:focus { border-color: var(--primary); background: transparent; box-shadow: 0 12px 24px -20px rgba(99, 102, 241, 0.6); }
    
    .feedback-area { text-align: center; margin-bottom: 1rem; min-height: 24px; }
    .diff-display span { font-size: 1.2rem; font-weight: 600; }
    .diff-correct { color: var(--text-main); }
    .diff-wrong { color: var(--error); font-weight: 700; }

    .srs-controls { display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-1); width: 100%; margin-top: var(--space-4); }
    .srs-btn { padding: var(--space-2); border-radius: var(--radius-sm); font-size: 0.9rem; font-weight: 700; color: #333; }
    .srs-again { background: #fee2e2; color: #991b1b; }
    .srs-hard { background: #ffedd5; color: #9a3412; }
    .srs-good { background: #dcfce7; color: #166534; }
    .srs-easy { background: #dbeafe; color: #1e40af; }

    /* --- DECK LIST --- */
    .deck-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: var(--space-2);
        border-bottom: 1px solid #f3f4f6;
        margin-bottom: var(--space-2);
    }
    .deck-item:last-child { border: none; margin-bottom: 0; padding-bottom: 0; }
    .deck-info h3 { margin: 0 0 4px 0; font-size: 1.1rem; }
    .deck-info small { color: var(--text-sub); }
    
    /* --- MODAL --- */
    .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 100;
        display: flex; align-items: center; justify-content: center;
        opacity: 0; pointer-events: none; transition: opacity 0.18s ease;
        backdrop-filter: blur(2px);
    }
    .modal-overlay.open { opacity: 1; pointer-events: auto; }
    .modal {
        background: white; width: 90%; max-width: 400px;
        padding: var(--space-3); border-radius: var(--radius);
        transform: translateY(20px); transition: transform 0.18s ease;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }
    .modal-overlay.open .modal { transform: translateY(0); }
    .modal-toggle {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 1rem;
    }
    .modal-toggle button {
        padding: var(--space-2);
        border-radius: var(--radius-sm);
        border: 2px solid var(--primary);
        background: transparent;
        color: var(--primary);
        font-weight: 600;
    }
    .modal-toggle button.active {
        background: var(--primary);
        color: white;
    }
    .modal-panel.hidden {
        display: none;
    }

    .deck-actions {
        display: grid;
        gap: var(--space-1);
    }

    .deck-actions .btn-secondary,
    .deck-actions .btn-primary {
        width: 100%;
    }
    
    /* --- ANIMATIONS --- */
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(99, 102, 241, 0); } 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    .hidden { display: none !important; }
    .status-badge { display: inline-block; padding: 4px 10px; border-radius: 999px; font-size: 0.8rem; margin-top: 5px; }
    .status-ok { background: #dcfce7; color: #166534; }
    .status-err { background: #fee2e2; color: #991b1b; }

    /* Diff display styling for incorrect answers */
    .diff-display {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        justify-content: center;
        margin-top: 8px;
        margin-bottom: 8px;
        font-size: 1.1rem;
        line-height: 1.5;
        text-align: center;
    }
    .diff-highlight {
        color: var(--error);
        font-weight: 700;
    }
    .diff-line {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 999px;
        background: #ffffff;
        border: 1px solid rgba(148, 163, 184, 0.3);
    }

    .practice-selection {
        display: flex;
        flex-direction: column;
        gap: var(--space-2);
    }
    .practice-deck-item {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        padding: var(--space-2);
        border: 1px solid #e5e7eb;
        border-radius: var(--radius-sm);
        background: #ffffff;
        transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
    }
    .practice-deck-item input {
        margin: 0;
        width: auto;
        accent-color: var(--primary);
    }
    .practice-deck-item.selected {
        border-color: var(--primary);
        background: #eef2ff;
        box-shadow: 0 6px 12px rgba(99, 102, 241, 0.15);
    }
    .practice-deck-details {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
    }
    .practice-deck-name {
        font-weight: 600;
        font-size: 0.98rem;
    }
    .practice-deck-meta {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-1);
        font-size: 0.78rem;
        color: var(--text-sub);
    }
    .practice-filters {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-1);
        margin: var(--space-2) 0 var(--space-1);
    }
    .practice-filter-btn {
        padding: 8px 16px;
        border-radius: 999px;
        border: 1px solid #e5e7eb;
        background: var(--accent-soft);
        color: var(--text-sub);
        font-size: 0.8rem;
        font-weight: 600;
    }
    .practice-filter-btn.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
    }
    .practice-header {
        display: flex;
        justify-content: flex-end;
        width: 100%;
        margin-bottom: 1rem;
    }
    .practice-end {
        color: var(--error);
        border-color: var(--error);
    }
    .practice-category-title {
        font-size: 0.95rem;
        color: var(--text-sub);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin: var(--space-1) 0 0;
    }
    .practice-category {
        display: flex;
        flex-direction: column;
        gap: var(--space-1);
    }
    .practice-empty {
        font-size: 0.9rem;
        color: var(--text-sub);
        margin: 0 0 8px;
    }
    .practice-progress {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: var(--space-1);
        margin: 0 auto var(--space-3);
    }
    .practice-progress-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.85rem;
        color: var(--text-sub);
        font-weight: 600;
    }

    .practice-preview {
        margin-top: var(--space-3);
        text-align: left;
        background: #ffffff;
        border-radius: var(--radius-sm);
        border: 1px solid rgba(99, 102, 241, 0.15);
        padding: var(--space-2);
    }

    .practice-preview-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: var(--space-1);
        margin-bottom: var(--space-1);
    }

    .practice-preview-title {
        font-weight: 700;
        color: var(--text-main);
    }

    .practice-preview-count {
        font-size: var(--font-small);
        color: var(--text-sub);
    }

    .practice-preview-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: var(--space-1);
    }

    .practice-preview-item {
        padding: var(--space-1);
        border-radius: 10px;
        background: var(--bg-card-soft);
        border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .practice-preview-item-title {
        font-weight: 600;
        color: var(--text-main);
        margin-bottom: 2px;
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
    }

    .practice-preview-tag {
        font-size: 0.7rem;
        padding: 2px 6px;
        border-radius: 999px;
        background: var(--accent-soft);
        color: #9a5a05;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.04em;
    }

    .practice-preview-pack {
        font-size: var(--font-small);
        color: var(--text-sub);
    }

    .practice-preview-note {
        font-size: var(--font-small);
        color: var(--text-sub);
        margin-top: var(--space-1);
    }
    .progress-track {
        width: 100%;
        height: 12px;
        background: #e5e7eb;
        border-radius: 999px;
        overflow: hidden;
    }
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--primary), var(--primary-dark));
        border-radius: 999px;
        transition: width 0.3s ease;
    }
    .practice-hint {
        margin-top: var(--space-1);
        font-size: 0.95rem;
        color: var(--text-sub);
        text-align: center;
    }
    .practice-hint strong {
        color: var(--primary-dark);
    }
    .feedback-positive {
        color: var(--success);
        font-weight: 700;
        font-size: 1.1rem;
    }
    .feedback-positive::before {
        content: "‚≠ê ";
    }
    .feedback-sub {
        margin-top: var(--space-1);
        font-size: 0.95rem;
        color: var(--text-sub);
    }
    .try-again-wrap {
        margin-top: 1rem;
        display: flex;
        justify-content: center;
    }
    .practice-options {
        display: grid;
        gap: var(--space-1);
        margin-bottom: var(--space-2);
    }
    .practice-option {
        padding: var(--space-2);
        border-radius: var(--radius-sm);
        border: 1px solid #e5e7eb;
        background: #ffffff;
        display: flex;
        flex-direction: column;
        gap: 4px;
        cursor: pointer;
        transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
    }
    .practice-option.selected {
        border-color: var(--primary);
        background: #eef2ff;
        box-shadow: 0 6px 12px rgba(99, 102, 241, 0.12);
    }
    .practice-option.disabled {
        opacity: 0.55;
        cursor: not-allowed;
    }
    .practice-option-title {
        font-weight: 700;
        font-size: 0.95rem;
    }
    .practice-option-desc {
        font-size: 0.85rem;
        color: var(--text-sub);
    }

    /* Toggle switch styling (borrowed from improved version) */
    .toggle {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
    }
    .toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--neutral-200);
        transition: 0.4s;
        border-radius: 24px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
    }
    .toggle input:checked + .slider {
        background-color: var(--primary);
    }
    .toggle input:checked + .slider:before {
        transform: translateX(26px);
    }
</style>
</head>
<body>

<header>
    <div class="header-top">
        <div class="app-title">SpellMaster</div>
        <div class="language-filter">
            <button class="language-filter-btn" id="language-filter-btn" type="button" onclick="toggleLanguageFilter()" aria-haspopup="listbox" aria-expanded="false">
                <span class="flag" id="language-filter-flag">üåê</span>
                <span id="language-filter-label">All languages</span>
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M7 10l5 5 5-5H7z"/></svg>
            </button>
            <div class="language-filter-menu" id="language-filter-menu" role="listbox" aria-label="Language filter"></div>
        </div>
    </div>
    <span class="app-tagline">Make spelling feel like a game</span>
</header>

<main>
    <!-- PRACTICE SCREEN -->
    <div id="view-practice" class="view active">
        <div class="practice-wrapper" id="practice-container">
            <!-- Dynamic Content -->
            <div style="text-align: center; color: var(--text-sub);">
                <h2>Let‚Äôs practice!</h2>
                <p>Tap start when you‚Äôre ready.</p>
                <br>
                <button class="btn-primary" onclick="startTodayPractice()">Start today‚Äôs challenge</button>
            </div>
        </div>
    </div>

    <!-- WORDS / DECKS SCREEN -->
    <div id="view-words" class="view">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h2>My Word Packs</h2>
            <button class="btn-secondary" onclick="openDeckModal()">+ New Pack</button>
        </div>
        <div class="card" id="deck-list-container">
            <div id="deck-list"></div>
        </div>
    </div>

    <!-- SETTINGS SCREEN -->
    <div id="view-settings" class="view">
        <h2>Settings</h2>
        
        <!-- Learning Settings -->
        <div class="card">
            <h3>Learning</h3>
            <div>
                <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span>Autoplay audio</span>
                    <label class="toggle"><input type="checkbox" id="setting-autoplay"><span class="slider"></span></label>
                </label>
                <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span>Block keyboard suggestions</span>
                    <label class="toggle"><input type="checkbox" id="setting-block-suggestions"><span class="slider"></span></label>
                </label>
                <label style="display:block; margin-bottom:8px;">
                    Answer strictness
                    <select id="setting-strictness" style="width:100%; margin-top:4px;">
                        <option value="strict">Strict</option>
                        <option value="lenient">Lenient</option>
                    </select>
                </label>
                <label style="display:block;">
                    Timer start
                    <select id="setting-timerStart" style="width:100%; margin-top:4px;">
                        <option value="show">On show</option>
                        <option value="audio">On audio</option>
                    </select>
                </label>
                <label style="display:block; margin-top:8px;">
                    Dictation repeats
                    <select id="setting-dictation-repeats" style="width:100%; margin-top:4px;">
                        <option value="0">No repeats</option>
                        <option value="1">1 repeat</option>
                        <option value="2">2 repeats</option>
                        <option value="3">3 repeats</option>
                    </select>
                </label>
                <p class="text-small" style="color: var(--text-sub);">
                    Dictation sentences play once automatically. Repeats are extra plays after the first.
                </p>
            </div>
        </div>

        <div class="card">
            <h3>Audio Diagnostics</h3>
            <p style="font-size:0.9rem; color: var(--text-sub);">If audio isn't working, check here.</p>
            <div id="audio-status" class="status-badge status-err">Checking...</div>
            <div style="margin-top:var(--space-1);">
                <label>Voice mode</label>
                <select id="setting-voice-mode">
                    <option value="auto">Auto (match pack language)</option>
                    <option value="fixed">Fixed (use selected voice)</option>
                </select>
                <p style="font-size:0.8rem; color: var(--text-sub); margin: var(--space-1) 0 var(--space-2);">
                    Auto mode chooses a voice that matches the pack language (e.g., Spanish packs use Spanish voices).
                </p>
            </div>
            <div>
                <label>System Voice</label>
                <select id="setting-voice"><option>Loading voices...</option></select>
            </div>
            <button class="btn-secondary" onclick="testAudio()">Test Audio</button>
        </div>

        <div class="card">
            <h3>Audio Speed Settings</h3>
            <p class="text-small" style="color: var(--text-sub);">
                These controls apply to specific exercises only.
            </p>

            <button class="settings-toggle" type="button" data-panel="audio-speed-text">
                Audio speed settings ‚Äî whole text
            </button>
            <div class="settings-panel" id="audio-speed-text">
                <div>
                    <label>Speed: <span id="speed-text-val">1.0</span>x</label>
                    <input type="range" id="setting-speed-text" min="0.5" max="1.5" step="0.1" value="1">
                </div>
                <div style="margin-top:var(--space-2);">
                    <label>Silence at start: <span id="pause-start-text-val">0</span> ms</label>
                    <input type="range" id="setting-pause-start-text" min="0" max="2000" step="5" value="0">
                </div>
                <div>
                    <label>Pause between sentences: <span id="pause-between-sentences-text-val">800</span> ms</label>
                    <input type="range" id="setting-pause-between-sentences-text" min="0" max="3000" step="5" value="800">
                </div>
                <div>
                    <label>Mid-sentence pause (commas/clauses): <span id="pause-mid-sentence-text-val">350</span> ms</label>
                    <input type="range" id="setting-pause-mid-sentence-text" min="0" max="1500" step="5" value="350">
                </div>
                <div>
                    <label>Pause after every word: <span id="pause-two-words-text-val">0</span> ms</label>
                    <input type="range" id="setting-pause-two-words-text" min="0" max="1500" step="5" value="0">
                </div>
            </div>

            <button class="settings-toggle" type="button" data-panel="audio-speed-sentence">
                Audio speed settings ‚Äî sentences
            </button>
            <div class="settings-panel" id="audio-speed-sentence">
                <div>
                    <label>Speed: <span id="speed-sentence-val">1.0</span>x</label>
                    <input type="range" id="setting-speed-sentence" min="0.5" max="1.5" step="0.1" value="1">
                </div>
                <div style="margin-top:var(--space-2);">
                    <label>Silence at start: <span id="pause-start-sentence-val">0</span> ms</label>
                    <input type="range" id="setting-pause-start-sentence" min="0" max="2000" step="5" value="0">
                </div>
                <div>
                    <label>Mid-sentence pause (commas/clauses): <span id="pause-mid-sentence-sentence-val">350</span> ms</label>
                    <input type="range" id="setting-pause-mid-sentence-sentence" min="0" max="1500" step="5" value="350">
                </div>
                <div>
                    <label>Pause after every word: <span id="pause-two-words-sentence-val">0</span> ms</label>
                    <input type="range" id="setting-pause-two-words-sentence" min="0" max="1500" step="5" value="0">
                </div>
            </div>

            <button class="settings-toggle" type="button" data-panel="audio-speed-word">
                Audio speed settings ‚Äî words
            </button>
            <div class="settings-panel" id="audio-speed-word">
                <div>
                    <label>Speed: <span id="speed-word-val">1.0</span>x</label>
                    <input type="range" id="setting-speed-word" min="0.5" max="1.5" step="0.1" value="1">
                </div>
                <div style="margin-top:var(--space-2);">
                    <label>Silence at start: <span id="pause-start-word-val">0</span> ms</label>
                    <input type="range" id="setting-pause-start-word" min="0" max="2000" step="5" value="0">
                </div>
                <div>
                    <label>Pause between word &amp; sentence: <span id="pause-word-sentence-word-val">600</span> ms</label>
                    <input type="range" id="setting-pause-word-sentence-word" min="0" max="2000" step="5" value="600">
                </div>
                <div>
                    <label>Mid-sentence pause (commas/clauses): <span id="pause-mid-sentence-word-val">350</span> ms</label>
                    <input type="range" id="setting-pause-mid-sentence-word" min="0" max="1500" step="5" value="350">
                </div>
                <div>
                    <label>Pause after every word: <span id="pause-two-words-word-val">0</span> ms</label>
                    <input type="range" id="setting-pause-two-words-word" min="0" max="1500" step="5" value="0">
                </div>
            </div>
        </div>
        
        <div class="card">
            <h3>Data Management</h3>
            <button class="btn-secondary" onclick="exportData()" style="width:100%; margin-bottom:var(--space-1);">Export Backup</button>
            <button class="btn-secondary" onclick="document.getElementById('import-file').click()" style="width:100%; margin-bottom:var(--space-1);">Import Backup</button>
            <input type="file" id="import-file" class="hidden" accept=".json">
            <button class="btn-secondary" style="color: var(--error); border-color: var(--error); width:100%;" onclick="resetApp()">Reset All Data</button>
        </div>
    </div>

    <!-- PROGRESS SCREEN -->
    <div id="view-progress" class="view">
        <h2>Next Up!</h2>
        <p class="text-small" style="color:var(--text-sub);">Focus on the next step that grows your mastery.</p>
        <div class="card" id="progress-overview" style="margin-bottom:1rem;"></div>
        <div class="card" id="progress-details"></div>
    </div>

    <!-- DECK PROGRESS SCREEN -->
    <div id="view-deck-progress" class="view">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:1rem;">
            <button class="btn-secondary" onclick="navTo('words')">‚Üê Back</button>
            <h2 style="margin:0;" id="deck-progress-title">Pack Progress</h2>
            <button class="btn-secondary" id="deck-reset-stats" onclick="resetDeckStats()">Reset Stats</button>
        </div>
        <div class="card" id="deck-progress-overview" style="margin-bottom:1rem;"></div>
        <div class="card" id="deck-progress-details"></div>
    </div>
</main>

<nav>
    <button onclick="navTo('practice')" id="nav-practice" class="active">
        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
        Today
    </button>
    <button onclick="navTo('words')" id="nav-words">
        <svg viewBox="0 0 24 24"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z"/></svg>
        Packs
    </button>
    <button onclick="navTo('progress')" id="nav-progress">
        <svg viewBox="0 0 24 24"><path d="M3 17h4V9H3v8zm6 0h4V5H9v12zm6 0h4V13h-4v4z"/></svg>
        Progress
    </button>

    <button onclick="navTo('settings')" id="nav-settings">
        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L5.09 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.58 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
        Settings
    </button>
</nav>

<!-- ADD DECK MODAL -->
<div id="deck-modal" class="modal-overlay">
    <div class="modal">
        <h3>Create a Word Pack</h3>
        <div class="modal-toggle">
            <button type="button" id="deck-toggle-create" class="active" onclick="showDeckPanel('create')">Create</button>
            <button type="button" id="deck-toggle-import" onclick="showDeckPanel('import')">Import Pack</button>
        </div>
        <div id="deck-panel-create" class="modal-panel">
            <label>Word Pack Name</label>
            <input type="text" id="new-deck-name" placeholder="e.g. Spanish Basics">
            <label>Language</label>
            <select id="new-deck-lang">
                <option value="en-US">English (US)</option>
                <option value="en-GB">English (UK)</option>
                <option value="es-ES">Spanish</option>
                <option value="fr-FR">French</option>
                <option value="de-DE">German</option>
                <option value="it-IT">Italian</option>
            </select>
            <label for="new-deck-text">Dictation Text or Word List (optional)</label>
            <textarea id="new-deck-text" rows="5" placeholder="Paste full dictation text, or a list like: apple, banana; or apple - An example sentence." style="width:100%; padding:var(--space-2); border:2px solid #e5e7eb; border-radius:var(--radius-sm); font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical;"></textarea>
            <p class="text-small" style="color:var(--text-sub); margin-top:6px;">
                Tip: Separate words with commas/semicolons, or use word-sentence pairs like "ocean: The ocean is calm; breeze / A light breeze blew."
            </p>
            <div style="display:flex; gap:var(--space-1); margin-top:var(--space-2);">
                <button class="btn-secondary" onclick="closeDeckModal()" style="flex:1">Cancel</button>
                <button class="btn-primary" onclick="saveDeck()" style="flex:1">Create Pack</button>
            </div>
        </div>
        <div id="deck-panel-import" class="modal-panel hidden">
            <p style="font-size:0.95rem; color:var(--text-sub); margin-top:0;">
                Import a compatible word pack JSON file to add it to your collection.
            </p>
            <button class="btn-secondary" onclick="triggerDeckImport()" style="width:100%; margin-bottom:var(--space-1);">Choose Pack File</button>
            <button class="btn-secondary" onclick="focusDeckPaste()" style="width:100%; margin-bottom:var(--space-1);">Paste Pack as JSON</button>
            <input type="file" id="import-deck-file" class="hidden" accept=".json,application/json">
            <div style="margin-bottom:var(--space-1);">
                <label for="import-deck-json" style="display:block; font-size:0.85rem; color:var(--text-sub); margin-bottom:6px;">
                    Paste pack as JSON
                </label>
                <textarea id="import-deck-json" rows="6" placeholder='{"name":"My Pack","lang":"en-US","text":"First sentence. Second sentence.","cards":[{"word":"example","sentence":"First sentence."}]}' style="width:100%; padding:var(--space-2); border:2px solid #e5e7eb; border-radius:var(--radius-sm); font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical;"></textarea>
            </div>
            <button class="btn-secondary" onclick="importDeckFromPaste()" style="width:100%; margin-bottom:var(--space-1);">Import Pasted Pack</button>
            <div style="display:flex; gap:var(--space-1);">
                <button class="btn-secondary" onclick="closeDeckModal()" style="flex:1">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- MANAGE CARDS MODAL -->
<div id="cards-modal" class="modal-overlay">
    <div class="modal" style="max-height: 85vh; display:flex; flex-direction:column;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3>Manage Cards</h3>
            <button class="btn-icon" onclick="closeCardsModal()">‚úï</button>
        </div>
        <div id="dictation-text-panel" style="margin-bottom:1rem; display:none;">
            <label for="edit-deck-text-inline">Dictation Text</label>
            <textarea id="edit-deck-text-inline" rows="5" placeholder="Edit the full dictation passage." style="width:100%; padding:var(--space-2); border:2px solid #e5e7eb; border-radius:var(--radius-sm); font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical; margin-bottom:8px;"></textarea>
            <div style="display:flex; align-items:center; justify-content:space-between; gap:var(--space-1); flex-wrap:wrap;">
                <small class="text-small" style="color: var(--text-sub);">Saving updates words and sentences to match the text.</small>
                <button class="btn-secondary" onclick="saveDictationText()">Save Dictation Text</button>
            </div>
        </div>
        <div style="margin-bottom:1rem;">
            <input type="text" id="new-card-word" placeholder="Word to spell" style="margin-bottom:8px;">
            <input type="text" id="new-card-sentence" placeholder="Sentence (optional)" style="margin-bottom:8px;">
            <!-- Optional audio URL input to support custom pronunciation files -->
            <input type="text" id="new-card-audio" placeholder="Audio URL (optional)" style="margin-bottom:8px;">
            <button class="btn-primary" onclick="addCardToDeck()">Add Card</button>
        </div>
        <div style="flex:1; overflow-y:auto; border-top:1px solid #eee; padding-top:var(--space-1);" id="cards-list-content">
            <!-- Cards list -->
        </div>
    </div>
</div>

<!-- EDIT CARD MODAL -->
<div id="card-edit-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3>Edit Card</h3>
            <button class="btn-icon" onclick="closeCardEditModal()">‚úï</button>
        </div>
        <label for="edit-card-word">Word</label>
        <input type="text" id="edit-card-word" placeholder="Word">
        <label for="edit-card-sentence">Sentence</label>
        <input type="text" id="edit-card-sentence" placeholder="Sentence (optional)">
        <label for="edit-card-audio">Audio URL</label>
        <input type="text" id="edit-card-audio" placeholder="Audio URL (optional)">
        <div style="display:flex; gap:var(--space-1);">
            <button class="btn-secondary" onclick="closeCardEditModal()" style="flex:1">Cancel</button>
            <button class="btn-primary" onclick="saveCardEdits()" style="flex:1">Save</button>
        </div>
    </div>
</div>

<!-- DECK ACTIONS MODAL -->
<div id="deck-actions-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3 id="deck-actions-title">Pack Actions</h3>
            <button class="btn-icon" onclick="closeDeckActionsModal()">‚úï</button>
        </div>
        <div class="deck-actions">
            <button class="btn-primary" onclick="openDeckStats()">Stats</button>
            <button class="btn-secondary" onclick="openDeckEditor()">Edit Words</button>
            <button class="btn-secondary" onclick="openDeckMetaEditor()">Edit Name/Language</button>
            <button class="btn-secondary" onclick="exportDeck()">Export Pack</button>
            <button class="btn-secondary" style="color: var(--error); border-color: var(--error);" onclick="deleteDeck()">Delete Pack</button>
        </div>
    </div>
</div>

<!-- PRACTICE OPTIONS MODAL -->
<div id="practice-options-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3 id="practice-options-title">Practice Options</h3>
            <button class="btn-icon" onclick="closePracticeOptionsModal()">‚úï</button>
        </div>
        <div id="practice-options-list" class="practice-options"></div>
        <p id="practice-options-note" class="text-small" style="color: var(--text-sub); margin-top:0;"></p>
        <button class="btn-primary" id="practice-options-start" onclick="startPracticeFromOptions()" disabled>Start challenge</button>
    </div>
</div>

<!-- EDIT DECK META MODAL -->
<div id="deck-meta-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3>Edit Name/Language</h3>
            <button class="btn-icon" onclick="closeDeckMetaModal()">‚úï</button>
        </div>
        <label for="edit-deck-name">Pack Name</label>
        <input type="text" id="edit-deck-name" placeholder="Pack name">
        <label for="edit-deck-lang">Language</label>
        <select id="edit-deck-lang">
            <option value="en-US">English (US)</option>
            <option value="en-GB">English (UK)</option>
            <option value="es-ES">Spanish</option>
            <option value="fr-FR">French</option>
            <option value="de-DE">German</option>
            <option value="it-IT">Italian</option>
        </select>
        <label for="edit-deck-text">Dictation Text (optional)</label>
        <textarea id="edit-deck-text" rows="5" placeholder="Enter the full dictation passage." style="width:100%; padding:var(--space-2); border:2px solid #e5e7eb; border-radius:var(--radius-sm); font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical;"></textarea>
        <div style="display:flex; gap:var(--space-1);">
            <button class="btn-secondary" onclick="closeDeckMetaModal()" style="flex:1">Cancel</button>
            <button class="btn-primary" onclick="saveDeckMeta()" style="flex:1">Save</button>
        </div>
    </div>
</div>

<script>
/**
 * APP DATA
 */
let app = {
    decks: [],
    settings: {
        voiceURI: null,
        voiceMode: 'auto',
        speed: 1.0,
        pauseStartMs: 0,
        pauseWordSentenceMs: 600,
        pauseBetweenSentencesMs: 800,
        pauseMidSentenceMs: 350,
        pauseTwoWordsMs: 0,
        audioProfiles: {},
        /* whether to automatically play audio when a card appears */
        autoplay: true,
        /* whether to block keyboard suggestions on the practice input */
        blockSuggestions: false,
        /* answer strictness: 'strict' = case-sensitive; 'lenient' = case-insensitive */
        strictness: 'strict',
        /* when to start timing user response: 'show' or 'audio' */
        timerStart: 'audio',
        /* number of extra repeats allowed after the first dictation play */
        dictationRepeats: 1,
        /* global language filter */
        languageFilter: 'all'
    }
};

let currentSession = {
    deck: null,
    decks: [],
    queue: [],
    currentCard: null,
    currentEntry: null,
    isAnswered: false,
    isActive: false,
    lastAnswerCorrect: null,
    selectedDeckIds: [],
    practiceFilter: 'all',
    startTime: null,
    sessionStartTime: null,
    totalCount: 0,
    completedCount: 0,
    correctAttempts: 0,
    totalAttempts: 0,
    troubleEntries: []
};

let lastSessionSummary = null;
let progressTroubleEntries = [];
let activePracticeDeckId = null;
let selectedPracticeMode = null;

// --- AUDIO ENGINE (ROBUST VERSION) ---
let availableVoices = [];

function initAudio() {
    const statusEl = document.getElementById('audio-status');
    const select = document.getElementById('setting-voice');

    if (!('speechSynthesis' in window)) {
        statusEl.className = 'status-badge status-err';
        statusEl.textContent = 'Not Supported in this Browser';
        select.innerHTML = '<option>Not available</option>';
        return;
    }

    // Attempt to load voices
    const loadVoices = () => {
        const freshVoices = window.speechSynthesis.getVoices();
        if (freshVoices.length > 0) {
            availableVoices = freshVoices;
            statusEl.className = 'status-badge status-ok';
            statusEl.textContent = 'Engine Ready';
            populateVoiceSelect();
            return true;
        }
        // Keep waiting or show warning
        statusEl.className = 'status-badge status-err';
        statusEl.textContent = 'Voices Empty (Try Chrome/Safari)';
        return false;
    };

    // Modern browsers load async
    window.speechSynthesis.onvoiceschanged = loadVoices;
    
    // Initial attempt
    loadVoices();
    
    // Some browsers need a kick
    setTimeout(loadVoices, 500);

    // Keep retrying briefly for browsers that populate voices late.
    let retries = 0;
    const retryTimer = setInterval(() => {
        retries += 1;
        const loaded = loadVoices();
        if (loaded || retries >= 10) {
            clearInterval(retryTimer);
        }
    }, 500);
}

function normalizeLangCode(lang) {
    return lang ? String(lang).replace('_', '-').toLowerCase() : '';
}

function getLanguageFlag(lang) {
    const normalized = normalizeLangCode(lang);
    if (!normalized || normalized === 'all') return 'üåê';
    const regionMap = {
        'en-us': 'üá∫üá∏',
        'en-gb': 'üá¨üáß',
        'es-es': 'üá™üá∏',
        'fr-fr': 'üá´üá∑',
        'de-de': 'üá©üá™',
        'it-it': 'üáÆüáπ'
    };
    if (regionMap[normalized]) return regionMap[normalized];
    const baseMap = {
        en: 'üá∫üá∏',
        es: 'üá™üá∏',
        fr: 'üá´üá∑',
        de: 'üá©üá™',
        it: 'üáÆüáπ'
    };
    const base = normalized.split('-')[0];
    return baseMap[base] || 'üè≥Ô∏è';
}

function getLanguageLabel(lang) {
    const normalized = normalizeLangCode(lang);
    if (!normalized || normalized === 'all') return 'All languages';
    const labels = {
        'en-us': 'English (US)',
        'en-gb': 'English (UK)',
        'es-es': 'Spanish',
        'fr-fr': 'French',
        'de-de': 'German',
        'it-it': 'Italian'
    };
    return labels[normalized] || lang;
}

function getAvailableLanguages() {
    const unique = new Map();
    app.decks.forEach(deck => {
        if (!deck || !deck.lang) return;
        const key = String(deck.lang);
        if (!unique.has(key)) {
            unique.set(key, {
                value: key,
                label: getLanguageLabel(key),
                flag: getLanguageFlag(key)
            });
        }
    });
    return Array.from(unique.values()).sort((a, b) => a.label.localeCompare(b.label));
}

function getFilteredDecks() {
    const filter = app.settings.languageFilter || 'all';
    if (filter === 'all') return app.decks;
    const normalizedFilter = normalizeLangCode(filter);
    return app.decks.filter(deck => normalizeLangCode(deck.lang) === normalizedFilter);
}

function updateLanguageFilterOptions() {
    const menu = document.getElementById('language-filter-menu');
    if (!menu) return;
    const filter = app.settings.languageFilter || 'all';
    const options = [
        { value: 'all', label: 'All languages', flag: 'üåê' },
        ...getAvailableLanguages()
    ];
    menu.innerHTML = options.map(option => `
        <button type="button" class="language-filter-option ${option.value === filter ? 'active' : ''}" data-value="${option.value}">
            <span class="flag">${option.flag}</span>
            <span>${option.label}</span>
        </button>
    `).join('');
    menu.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
            setLanguageFilter(btn.dataset.value);
            closeLanguageFilter();
        });
    });
}

function updateLanguageFilterUI() {
    const flagEl = document.getElementById('language-filter-flag');
    const labelEl = document.getElementById('language-filter-label');
    if (!flagEl || !labelEl) return;
    const filter = app.settings.languageFilter || 'all';
    flagEl.textContent = getLanguageFlag(filter);
    labelEl.textContent = getLanguageLabel(filter);
}

function toggleLanguageFilter() {
    const menu = document.getElementById('language-filter-menu');
    const btn = document.getElementById('language-filter-btn');
    if (!menu || !btn) return;
    const shouldOpen = !menu.classList.contains('open');
    if (shouldOpen) {
        updateLanguageFilterOptions();
        menu.classList.add('open');
    } else {
        menu.classList.remove('open');
    }
    btn.setAttribute('aria-expanded', String(shouldOpen));
}

function closeLanguageFilter() {
    const menu = document.getElementById('language-filter-menu');
    const btn = document.getElementById('language-filter-btn');
    if (!menu || !btn) return;
    menu.classList.remove('open');
    btn.setAttribute('aria-expanded', 'false');
}

function setLanguageFilter(value) {
    app.settings.languageFilter = value || 'all';
    saveData();
    updateLanguageFilterUI();
    updateLanguageFilterOptions();
    renderDeckList();
    renderProgress();
    if (!currentSession.isActive) {
        renderPracticeHome();
    }
}

function initLanguageFilter() {
    updateLanguageFilterOptions();
    updateLanguageFilterUI();
    document.addEventListener('click', (event) => {
        if (!event.target.closest('.language-filter')) {
            closeLanguageFilter();
        }
    });
}

function getBestVoiceForLang(lang) {
    if (!lang) return null;
    const normalized = normalizeLangCode(lang);
    const baseLang = normalized.split('-')[0];
    const exactMatches = availableVoices.filter(v => normalizeLangCode(v.lang) === normalized);
    const baseMatches = availableVoices.filter(v => {
        const voiceLang = normalizeLangCode(v.lang);
        return voiceLang && voiceLang.startsWith(baseLang);
    });
    const candidates = exactMatches.length ? exactMatches : baseMatches;
    if (!candidates.length) return null;
    return candidates.find(v => v.default) || candidates.find(v => v.localService) || candidates[0];
}

function updateVoiceModeUI() {
    const modeEl = document.getElementById('setting-voice-mode');
    const voiceSelect = document.getElementById('setting-voice');
    if (!modeEl || !voiceSelect) return;
    voiceSelect.disabled = modeEl.value === 'auto';
}

function populateVoiceSelect() {
    const select = document.getElementById('setting-voice');
    select.innerHTML = '';
    
    // Group by language
    availableVoices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI;
        opt.textContent = `${v.name} (${v.lang})`;
        select.appendChild(opt);
    });

    // Restore saved choice
    if (app.settings.voiceURI) {
        // Verify it still exists
        const exists = availableVoices.find(v => v.voiceURI === app.settings.voiceURI);
        if (exists) select.value = app.settings.voiceURI;
    }
    updateVoiceModeUI();
}

const AUDIO_PROFILE_DEFAULTS = {
    speed: 1.0,
    pauseStartMs: 0,
    pauseWordSentenceMs: 600,
    pauseBetweenSentencesMs: 800,
    pauseMidSentenceMs: 350,
    pauseTwoWordsMs: 0
};

function getPauseValue(value, fallback) {
    const parsed = Number.parseFloat(value);
    if (!Number.isFinite(parsed)) return fallback;
    return Math.max(0, parsed);
}

function getProfileSetting(profile, key, fallback) {
    return getPauseValue(profile?.[key], fallback);
}

function getLegacyAudioSettings() {
    const legacy = {};
    const speed = Number.parseFloat(app.settings.speed);
    if (Number.isFinite(speed)) legacy.speed = speed;
    ['pauseStartMs', 'pauseWordSentenceMs', 'pauseBetweenSentencesMs', 'pauseMidSentenceMs', 'pauseTwoWordsMs'].forEach((key) => {
        const parsed = Number.parseFloat(app.settings[key]);
        if (Number.isFinite(parsed)) legacy[key] = parsed;
    });
    return legacy;
}

function getAudioProfile(mode) {
    const profiles = app.settings.audioProfiles || {};
    const legacy = getLegacyAudioSettings();
    return {
        ...AUDIO_PROFILE_DEFAULTS,
        ...legacy,
        ...(profiles[mode] || {})
    };
}

function setAudioProfileSetting(mode, key, value) {
    if (!app.settings.audioProfiles) app.settings.audioProfiles = {};
    if (!app.settings.audioProfiles[mode]) app.settings.audioProfiles[mode] = {};
    app.settings.audioProfiles[mode][key] = value;
}

function getAudioProfileKeyForEntry(entry) {
    if (!entry) return 'word';
    if (entry.mode === 'dictation-text') return 'dictationText';
    if (entry.mode === 'dictation') return 'sentence';
    return 'word';
}

function selectVoiceForLang(lang) {
    let voice = null;
    if (app.settings.voiceMode === 'fixed' && app.settings.voiceURI) {
        voice = availableVoices.find(v => v.voiceURI === app.settings.voiceURI);
    }
    if (!voice && lang) {
        voice = getBestVoiceForLang(lang);
    }
    return voice;
}

function buildSentenceParts(sentence) {
    const clean = String(sentence || '').trim();
    if (!clean) return [];
    const commaParts = clean.split(/,\s*/).filter(Boolean);
    if (commaParts.length > 1) return commaParts;
    const words = clean.split(/\s+/).filter(Boolean);
    if (words.length > 6) {
        const midpoint = Math.ceil(words.length / 2);
        return [
            words.slice(0, midpoint).join(' '),
            words.slice(midpoint).join(' ')
        ];
    }
    return [clean];
}

function buildSentenceSegments(sentence, pauseMs, pauseTwoWordsMs = 0) {
    const parts = buildSentenceParts(sentence);
    const segments = [];
    parts.forEach((part, partIndex) => {
        const words = part.split(/\s+/).filter(Boolean);
        if (pauseTwoWordsMs > 0 && words.length > 1) {
            words.forEach((word, wordIndex) => {
                const isLastWord = wordIndex === words.length - 1;
                const pauseAfter = isLastWord
                    ? (partIndex < parts.length - 1 ? pauseMs : 0)
                    : pauseTwoWordsMs;
                segments.push({ text: word, pauseAfter });
            });
            return;
        }
        segments.push({
            text: part,
            pauseAfter: partIndex < parts.length - 1 ? pauseMs : 0
        });
    });
    return segments;
}

function speakSegments(segments, lang, profile = AUDIO_PROFILE_DEFAULTS) {
    if (!('speechSynthesis' in window)) {
        alert("Your browser does not support Audio. Please try Chrome or Safari.");
        return;
    }

    if (availableVoices.length === 0) {
        const freshVoices = window.speechSynthesis.getVoices();
        if (freshVoices.length > 0) {
            availableVoices = freshVoices;
            populateVoiceSelect();
        }
    }
    
    window.speechSynthesis.cancel(); // Stop current

    const validSegments = (segments || []).filter(segment => segment && (segment.text || segment.pauseAfter));
    if (!validSegments.length) return;

    const voice = selectVoiceForLang(lang);
    const btn = document.querySelector('.audio-trigger');
    if (btn) btn.classList.add('playing');

    let index = 0;
    const startDelay = getProfileSetting(profile, 'pauseStartMs', AUDIO_PROFILE_DEFAULTS.pauseStartMs);

    const finishSequence = () => {
        if (btn) btn.classList.remove('playing');
    };

    const speakNext = () => {
        if (index >= validSegments.length) {
            finishSequence();
            return;
        }
        const segment = validSegments[index];
        const pauseAfter = getPauseValue(segment.pauseAfter, 0);
        const advance = () => {
            index += 1;
            if (pauseAfter > 0) {
                setTimeout(speakNext, pauseAfter);
            } else {
                speakNext();
            }
        };

        if (!segment.text) {
            advance();
            return;
        }

        const u = new SpeechSynthesisUtterance(segment.text);
        const rate = Number.parseFloat(profile.speed);
        u.rate = Number.isFinite(rate) ? rate : AUDIO_PROFILE_DEFAULTS.speed;
        if (voice) {
            u.voice = voice;
            u.lang = voice.lang;
        } else {
            u.lang = lang || 'en-US';
        }
        u.onend = advance;
        u.onerror = (e) => {
            console.warn("Audio Error:", e);
            advance();
        };
        window.speechSynthesis.speak(u);
    };

    if (startDelay > 0) {
        setTimeout(speakNext, startDelay);
    } else {
        speakNext();
    }
}

function speak(text, lang, profile) {
    speakSegments([{ text, pauseAfter: 0 }], lang, profile);
}

function speakSentenceWithPauses(sentence, lang, profile) {
    const pauseMidSentenceMs = getProfileSetting(profile, 'pauseMidSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseMidSentenceMs);
    const pauseTwoWordsMs = getProfileSetting(profile, 'pauseTwoWordsMs', AUDIO_PROFILE_DEFAULTS.pauseTwoWordsMs);
    const segments = buildSentenceSegments(sentence, pauseMidSentenceMs, pauseTwoWordsMs);
    speakSegments(segments, lang, profile);
}

function speakWordWithSentence(word, sentence, lang, profile) {
    const pauseWordSentenceMs = getProfileSetting(profile, 'pauseWordSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseWordSentenceMs);
    const pauseMidSentenceMs = getProfileSetting(profile, 'pauseMidSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseMidSentenceMs);
    const pauseTwoWordsMs = getProfileSetting(profile, 'pauseTwoWordsMs', AUDIO_PROFILE_DEFAULTS.pauseTwoWordsMs);
    const segments = [
        { text: word, pauseAfter: pauseWordSentenceMs },
        ...buildSentenceSegments(sentence, pauseMidSentenceMs, pauseTwoWordsMs)
    ];
    speakSegments(segments, lang, profile);
}

function speakTextWithPauses(text, lang, profile) {
    const pauseBetweenSentencesMs = getProfileSetting(profile, 'pauseBetweenSentencesMs', AUDIO_PROFILE_DEFAULTS.pauseBetweenSentencesMs);
    const pauseMidSentenceMs = getProfileSetting(profile, 'pauseMidSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseMidSentenceMs);
    const pauseTwoWordsMs = getProfileSetting(profile, 'pauseTwoWordsMs', AUDIO_PROFILE_DEFAULTS.pauseTwoWordsMs);
    const sentences = splitTextIntoSentences(text || '');
    if (!sentences.length) {
        speak(text, lang, profile);
        return;
    }
    const segments = [];
    sentences.forEach((sentence, index) => {
        const sentenceSegments = buildSentenceSegments(sentence, pauseMidSentenceMs, pauseTwoWordsMs);
        if (sentenceSegments.length && index < sentences.length - 1) {
            sentenceSegments[sentenceSegments.length - 1].pauseAfter += pauseBetweenSentencesMs;
        }
        segments.push(...sentenceSegments);
    });
    speakSegments(segments, lang, profile);
}

function testAudio() {
    const modeEl = document.getElementById('setting-voice-mode');
    const s = document.getElementById('setting-voice');
    let lang = 'en-US';
    if (modeEl && modeEl.value === 'fixed') {
        const v = availableVoices.find(v => v.voiceURI === s.value);
        lang = v ? v.lang : lang;
    } else {
        lang = app.decks.length > 0 ? app.decks[0].lang : lang;
    }
    const profile = getAudioProfile('sentence');
    speak("This is a test of the audio system.", lang, profile);
}

// --- PERSISTENCE ---
function loadData() {
    const raw = localStorage.getItem('spellmaster_data_v2');
    if (raw) {
        try {
            const data = JSON.parse(raw);
            app.decks = data.decks || [];
            app.settings = { ...app.settings, ...data.settings };
        } catch(e) { console.error("Data load error", e); }
    }
    // Ensure all cards have expected properties (migration for newer versions)
    app.decks.forEach(deck => {
        if (deck.uncompleted === undefined) deck.uncompleted = false;
        if (deck.lastPracticed === undefined) deck.lastPracticed = null;
        if (deck.text === undefined) deck.text = '';
        if (deck.dictationStatsReady === undefined) deck.dictationStatsReady = false;
        deck.cards.forEach(card => {
            if (card.audioUrl === undefined) card.audioUrl = '';
            if (card.correctCount === undefined) card.correctCount = 0;
            if (card.incorrectCount === undefined) card.incorrectCount = 0;
            if (card.avgTime === undefined) card.avgTime = 0;
            if (card.interval === undefined) card.interval = 0;
            if (card.ease === undefined) card.ease = 2.5;
            if (card.due === undefined) card.due = 0;
        });
        if (!deck.dictationStatsReady) {
            deck.dictationStatsReady = deck.cards.some(card => (card.correctCount || 0) + (card.incorrectCount || 0) > 0);
        }
    });
    renderDeckList();
    updateLanguageFilterOptions();
    updateLanguageFilterUI();
    initSettingsListeners();
    renderPracticeHome();
}

function saveData() {
    localStorage.setItem('spellmaster_data_v2', JSON.stringify(app));
}

// --- NAV ---
function navTo(screen) {
    document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
    document.getElementById('view-' + screen).classList.add('active');
    
    document.querySelectorAll('nav button').forEach(el => el.classList.remove('active'));
    const navBtn = document.getElementById('nav-' + screen);
    if (navBtn) navBtn.classList.add('active');
    
    if (screen === 'words') {
        renderDeckList();
    } else if (screen === 'progress') {
        renderProgress();
    } else if (screen === 'practice') {
        if (!currentSession.isActive) {
            renderPracticeHome();
        }
    }
}

// --- PRACTICE ---
function startPractice(deckIds) {
    const selectedDecks = app.decks.filter(d => deckIds.includes(d.id));
    if (!selectedDecks.length) return;
    
    // Sort by due date
    const now = Date.now();
    let entries = selectedDecks.flatMap(deck => {
        if (isDictationDeck(deck) && !deckHasDictationStats(deck)) {
            return buildDictationTextEntry(deck);
        }
        if (isDictationDeck(deck)) {
            return buildDictationEntries(deck);
        }
        return buildWordEntries(deck, now, true);
    }).sort((a,b) => {
        if (a.mode === 'dictation' || b.mode === 'dictation') return 0;
        if (a.mode === 'dictation-text' || b.mode === 'dictation-text') return 0;
        return a.card.due - b.card.due;
    });
    
    // If no due cards, practice all
    if (entries.length === 0) {
        entries = selectedDecks.flatMap(deck => {
            if (isDictationDeck(deck) && !deckHasDictationStats(deck)) {
                return buildDictationTextEntry(deck);
            }
            if (isDictationDeck(deck)) {
                return buildDictationEntries(deck);
            }
            return buildWordEntries(deck, now, false);
        });
    }

    if (entries.length === 0) {
        alert("No cards available in the selected packs.");
        return;
    }

    startPracticeEntries(entries, selectedDecks);
}

function startPracticeEntries(entries, selectedDecks = []) {
    currentSession.queue = entries.slice();
    currentSession.deck = null;
    currentSession.decks = selectedDecks;
    currentSession.isActive = true;
    currentSession.sessionStartTime = Date.now();
    currentSession.totalCount = entries.length;
    currentSession.completedCount = 0;
    currentSession.correctAttempts = 0;
    currentSession.totalAttempts = 0;
    currentSession.troubleEntries = [];
    lastSessionSummary = null;
    navTo('practice');
    nextCard();
}

function startPracticeFromSelection() {
    const selected = currentSession.selectedDeckIds || [];
    if (!selected.length) {
        alert("Select at least one pack to practice.");
        return;
    }
    startPractice(selected);
}

function startTodayPractice() {
    const decks = getFilteredDecks();
    if (!decks.length) {
        alert("No packs match this language filter yet.");
        return;
    }
    const deckIds = decks.map(deck => deck.id);
    startPractice(deckIds);
}

function startTroublePractice() {
    if (!lastSessionSummary || !Array.isArray(lastSessionSummary.troubleEntries)) {
        return;
    }
    const uniqueMap = new Map();
    lastSessionSummary.troubleEntries.forEach(entry => {
        const key = `${entry.deck.id}-${entry.card.word}`;
        if (!uniqueMap.has(key)) {
            uniqueMap.set(key, entry);
        }
    });
    const entries = Array.from(uniqueMap.values());
    if (!entries.length) return;
    const selectedDecks = Array.from(new Set(entries.map(entry => entry.deck)));
    startPracticeEntries(entries, selectedDecks);
}

function startProgressTroublePractice() {
    if (!progressTroubleEntries.length) return;
    const uniqueMap = new Map();
    progressTroubleEntries.forEach(entry => {
        const key = `${entry.deck.id}-${entry.card.word}`;
        if (!uniqueMap.has(key)) {
            uniqueMap.set(key, entry);
        }
    });
    const entries = Array.from(uniqueMap.values());
    if (!entries.length) return;
    const selectedDecks = Array.from(new Set(entries.map(entry => entry.deck)));
    startPracticeEntries(entries, selectedDecks);
}

function openPasteList() {
    openDeckModal();
    showDeckPanel('import');
    setTimeout(() => focusDeckPaste(), 0);
}

function triggerBackupRestore() {
    const input = document.getElementById('import-file');
    if (input) {
        input.click();
    }
}

function addSampleDeck() {
    app.decks.push(createSampleDeck());
    saveData();
    renderDeckList();
    renderPracticeHome();
}

function endPracticeSession() {
    if (!currentSession.isActive) return;
    if (!confirm("End this practice session early?")) return;
    const remainingDeckIds = new Set(currentSession.queue.map(entry => entry.deck.id));
    currentSession.decks.forEach(deck => {
        deck.uncompleted = remainingDeckIds.has(deck.id);
    });
    saveData();
    currentSession.isActive = false;
    currentSession.queue = [];
    currentSession.currentCard = null;
    currentSession.currentEntry = null;
    currentSession.deck = null;
    currentSession.decks = [];
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    currentSession.startTime = null;
    currentSession.sessionStartTime = null;
    currentSession.totalCount = 0;
    currentSession.completedCount = 0;
    currentSession.correctAttempts = 0;
    currentSession.totalAttempts = 0;
    currentSession.troubleEntries = [];
    if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
    }
    renderPracticeHome();
}

function renderPracticeHome() {
    const container = document.getElementById('practice-container');
    if (!container) return;

    if (app.decks.length === 0) {
        container.innerHTML = `
            <div class="card" style="text-align:center;">
                <h2 style="margin-top:0;">Welcome to SpellMaster</h2>
                <p style="color: var(--text-sub); margin-bottom:1.5rem;">
                    Choose a starting point to set up your first pack.
                </p>
                <div style="display:grid; gap:var(--space-1);">
                    <button class="btn-primary" onclick="addSampleDeck()">Try a sample pack</button>
                    <button class="btn-secondary" onclick="openPasteList()">Paste list</button>
                    <button class="btn-secondary" onclick="triggerBackupRestore()">Restore backup</button>
                </div>
            </div>
        `;
        return;
    }
    const filteredDecks = getFilteredDecks();
    if (filteredDecks.length === 0) {
        container.innerHTML = `
            <div class="card" style="text-align:center;">
                <h2 style="margin-top:0;">No packs in this language</h2>
                <p style="color: var(--text-sub); margin-bottom:1.5rem;">
                    Try a different language filter to see your packs.
                </p>
                <button class="btn-secondary" onclick="toggleLanguageFilter()">Change language filter</button>
            </div>
        `;
        return;
    }
    const now = Date.now();
    const { totalCards } = getTodayCounts(now);
    const isStartDisabled = totalCards === 0;
    const todayEntries = getTodayEntries(now);
    const previewLimit = 6;
    const previewEntries = todayEntries.slice(0, previewLimit);
    const previewItems = previewEntries.map(entry => {
        const preview = formatPracticePreviewEntry(entry);
        return `
            <li class="practice-preview-item">
                <div class="practice-preview-item-title">
                    <span class="practice-preview-tag">${preview.type}</span>
                    <span>${preview.text}</span>
                </div>
                <div class="practice-preview-pack">Pack: ${preview.pack}</div>
            </li>
        `;
    }).join('');
    const previewNote = todayEntries.length > previewLimit
        ? `Showing ${previewLimit} of ${todayEntries.length} items.`
        : `Showing ${todayEntries.length || 0} item${todayEntries.length === 1 ? '' : 's'}.`;

    container.innerHTML = `
        <h2 style="margin-top:0; text-align:center;">Today</h2>
        <button class="btn-primary" ${isStartDisabled ? 'disabled' : ''} onclick="startTodayPractice()">Start today‚Äôs challenge</button>
        <div class="practice-preview">
            <div class="practice-preview-header">
                <div class="practice-preview-title">Up next</div>
                <div class="practice-preview-count">${todayEntries.length} total</div>
            </div>
            ${todayEntries.length === 0
                ? '<div class="practice-preview-note">No practice items available yet.</div>'
                : `
                    <ul class="practice-preview-list">
                        ${previewItems}
                    </ul>
                    <div class="practice-preview-note">${previewNote}</div>
                `}
        </div>
        <div style="margin-top:var(--space-3); display:grid; gap:var(--space-1);">
            <button class="btn-secondary" onclick="navTo('words')">Go to Packs</button>
        </div>
    `;
}

function formatDuration(ms) {
    if (!ms || ms < 0) return '0:00';
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function getHintMarkup(word) {
    if (!word) return '';
    const safeWord = String(word).trim();
    const firstLetter = safeWord.charAt(0).toUpperCase();
    const lengthHint = safeWord.split('').map(() => '_').join(' ');
    return `<div class="practice-hint">Hint: starts with <strong>${firstLetter}</strong> ‚Ä¢ ${lengthHint}</div>`;
}

function nextCard() {
    if (currentSession.queue.length === 0) {
        const totalAttempts = currentSession.totalAttempts || 0;
        const correctAttempts = currentSession.correctAttempts || 0;
        const accuracy = totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0;
        const durationMs = currentSession.sessionStartTime ? Date.now() - currentSession.sessionStartTime : 0;
        const troubleEntries = currentSession.troubleEntries || [];
        lastSessionSummary = {
            accuracy,
            durationMs,
            troubleEntries
        };
        const troubleButton = troubleEntries.length > 0
            ? `<button class="btn-secondary" onclick="startTroublePractice()">Practice trouble words</button>`
            : '';
        document.getElementById('practice-container').innerHTML = `
            <div class="card" style="text-align:center">
                <h2 style="margin-top:0;">Completed</h2>
                <p style="color:var(--text-sub); margin-bottom:1.5rem;">You finished this session.</p>
                <div style="display:grid; gap:8px; text-align:left; margin-bottom:1.5rem;">
                    <div><strong>Accuracy:</strong> ${accuracy}%</div>
                    <div><strong>Time:</strong> ${formatDuration(durationMs)}</div>
                </div>
                <div style="display:grid; gap:var(--space-1);">
                    <button class="btn-primary" onclick="navTo('practice'); renderPracticeHome();">Practice More</button>
                    ${troubleButton}
                </div>
            </div>`;
        currentSession.decks.forEach(deck => {
            deck.uncompleted = false;
        });
        saveData();
        currentSession.isActive = false;
        currentSession.currentCard = null;
        currentSession.currentEntry = null;
        currentSession.deck = null;
        currentSession.sessionStartTime = null;
        currentSession.totalCount = 0;
        currentSession.completedCount = 0;
        currentSession.correctAttempts = 0;
        currentSession.totalAttempts = 0;
        currentSession.troubleEntries = [];
        return;
    }

    currentSession.currentEntry = currentSession.queue[0];
    currentSession.currentCard = currentSession.currentEntry.card || currentSession.currentEntry.primaryCard || null;
    currentSession.deck = currentSession.currentEntry.deck;
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    // Reset timer
    currentSession.startTime = null;
    
    const c = currentSession.currentCard;
    const entry = currentSession.currentEntry;
    const isDictation = entry.mode === 'dictation' || entry.mode === 'dictation-text';
    const isDictationText = entry.mode === 'dictation-text';
    const hasSentence = !isDictation && c && c.sentence && c.sentence.trim() !== "";
    
    // Hide target word in sentence
    let sentenceDisplay = "";
    if (hasSentence) {
        // Regex to match word case-insensitive
        const regex = new RegExp(`\\b${escapeRegExp(c.word)}\\b`, 'gi');
        sentenceDisplay = c.sentence.replace(regex, "____");
    }

    const totalCount = currentSession.totalCount || currentSession.queue.length;
    const currentIndex = Math.min(currentSession.completedCount + 1, totalCount);
    const progressPercent = totalCount ? Math.round((currentIndex / totalCount) * 100) : 0;
    const hintMarkup = !isDictation && c ? getHintMarkup(c.word) : '';
    const dictationNotice = isDictation ? `
        <p style="font-size:1rem; color:var(--text-sub); margin-bottom:var(--space-3); text-align:center;">
            ${isDictationText
                ? `Dictation text with ${entry.sentenceCount || 1} sentence${entry.sentenceCount === 1 ? '' : 's'}. Listen and type the full text.`
                : `Dictation sentence ${entry.sentenceIndex} of ${entry.sentenceCount}. Listen and type the full sentence.`}
        </p>
        <div class="dictation-repeat-status" id="dictation-repeat-status"></div>
    ` : '';
    const html = `
        <div class="practice-header">
            <button class="btn-secondary practice-end" onclick="endPracticeSession()">End Session</button>
        </div>
        <div class="practice-progress">
            <div class="practice-progress-header">
                <span>Progress</span>
                <span>${currentIndex} / ${totalCount}</span>
            </div>
            <div class="progress-track" aria-hidden="true">
                <div class="progress-fill" style="width:${progressPercent}%"></div>
            </div>
        </div>
        <div class="audio-stack">
            <div class="audio-trigger" onclick="playCurrent()" role="button" aria-label="Play audio">
                <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            </div>
            <div class="audio-label">Play</div>
        </div>
        ${dictationNotice}
        ${hasSentence ? `<p style="font-size:1.2rem; color:var(--text-sub); margin-bottom:var(--space-4); text-align:center; padding:0 var(--space-3); line-height:1.5;">${sentenceDisplay}</p>` : ''}
        
        <div class="feedback-area" id="feedback"></div>
        
        <input type="text" id="p-input" class="word-input" placeholder="${isDictationText ? 'Type full text here' : (isDictation ? 'Type sentence here' : 'Type word here')}">
        ${hintMarkup}
        
        <button id="btn-check" class="btn-primary" style="margin-top:var(--space-2);" onclick="checkAnswer()">Check</button>
        
        <div id="srs-area" class="srs-controls hidden">
            <button class="srs-btn srs-again" onclick="rateCard(1)">Again</button>
            <button class="srs-btn srs-hard" onclick="rateCard(2)">Hard</button>
            <button class="srs-btn srs-good" onclick="rateCard(3)">Good</button>
            <button class="srs-btn srs-easy" onclick="rateCard(4)">Easy</button>
        </div>
    `;
    
    document.getElementById('practice-container').innerHTML = html;
    
    const input = document.getElementById('p-input');
    applySuggestionSettingToInput(input);
    input.focus();
    if (isDictation) {
        initDictationPlayback(entry);
        updateDictationRepeatStatus(entry);
    }
    
    // Set timer if start on show
    if (app.settings.timerStart === 'show') {
        currentSession.startTime = Date.now();
    }
    // Autoplay audio if enabled, dictation always plays once
    const shouldAutoplay = isDictation ? true : app.settings.autoplay;
    if (shouldAutoplay) {
        setTimeout(() => {
            playCurrent({ isAuto: true });
        }, 300);
    }

    // Keyboard support
    input.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
        if (currentSession.isAnswered) return;
        e.preventDefault();
        e.stopPropagation();
        checkAnswer();
    });
}

function applySuggestionSettingToInput(input) {
    if (!input) return;
    const shouldBlock = Boolean(app.settings.blockSuggestions);
    if (shouldBlock) {
        input.setAttribute('autocomplete', 'off');
        input.setAttribute('autocorrect', 'off');
        input.setAttribute('autocapitalize', 'off');
        input.setAttribute('spellcheck', 'false');
        input.setAttribute('aria-autocomplete', 'none');
    } else {
        input.removeAttribute('autocomplete');
        input.removeAttribute('autocorrect');
        input.removeAttribute('autocapitalize');
        input.removeAttribute('spellcheck');
        input.removeAttribute('aria-autocomplete');
    }
}

function initDictationPlayback(entry) {
    if (!entry || (entry.mode !== 'dictation' && entry.mode !== 'dictation-text')) return;
    entry.dictationPlayedOnce = false;
    entry.dictationRepeatsLeft = Number.isFinite(app.settings.dictationRepeats)
        ? Math.max(0, app.settings.dictationRepeats)
        : 1;
}

function updateDictationRepeatStatus(entry) {
    if (!entry || (entry.mode !== 'dictation' && entry.mode !== 'dictation-text')) return;
    const statusEl = document.getElementById('dictation-repeat-status');
    const audioBtn = document.querySelector('.audio-trigger');
    if (!statusEl) return;
    const repeatsLeft = Number(entry.dictationRepeatsLeft) || 0;
    const playedOnce = Boolean(entry.dictationPlayedOnce);
    if (!playedOnce) {
        statusEl.textContent = 'First listen is playing.';
        if (audioBtn) audioBtn.classList.remove('disabled');
        return;
    }
    if (repeatsLeft > 0) {
        statusEl.textContent = `Repeats left: ${repeatsLeft}`;
        if (audioBtn) audioBtn.classList.remove('disabled');
        return;
    }
    statusEl.textContent = 'No repeats left.';
    if (audioBtn) audioBtn.classList.add('disabled');
}

function consumeDictationPlay(entry) {
    if (!entry || (entry.mode !== 'dictation' && entry.mode !== 'dictation-text')) return true;
    if (!entry.dictationPlayedOnce) {
        entry.dictationPlayedOnce = true;
        updateDictationRepeatStatus(entry);
        return true;
    }
    const repeatsLeft = Number(entry.dictationRepeatsLeft) || 0;
    if (repeatsLeft <= 0) {
        updateDictationRepeatStatus(entry);
        return false;
    }
    entry.dictationRepeatsLeft = repeatsLeft - 1;
    updateDictationRepeatStatus(entry);
    return true;
}

function playCurrent(options = {}) {
    if (!currentSession.currentEntry) return;
    const card = currentSession.currentCard;
    const entry = currentSession.currentEntry;
    if (entry.mode === 'dictation' || entry.mode === 'dictation-text') {
        const canPlay = consumeDictationPlay(entry);
        if (!canPlay) return;
    }
    // Play custom audio if URL exists
    if (entry.mode !== 'dictation' && card && card.audioUrl) {
        try {
            const audio = new Audio(card.audioUrl);
            const btn = document.querySelector('.audio-trigger');
            if (btn) btn.classList.add('playing');
            audio.onplay = () => {
                if (app.settings.timerStart === 'audio') {
                    currentSession.startTime = Date.now();
                }
            };
            audio.onended = () => { if (btn) btn.classList.remove('playing'); };
            audio.onerror = () => {
                if (btn) btn.classList.remove('playing');
                // fallback to TTS if audio fails
                speakCard();
            };
            audio.play().catch((err) => {
                if (btn) btn.classList.remove('playing');
                speakCard();
            });
            return;
        } catch(e) {
            // fallback to speech synthesis
            speakCard();
            return;
        }
    }
    // Fallback to TTS
    speakCard();
    function speakCard() {
        // If timing starts on audio, start timer now
        if (app.settings.timerStart === 'audio') {
            currentSession.startTime = Date.now();
        }
        const lang = currentSession.deck ? currentSession.deck.lang : 'en-US';
        const profileKey = getAudioProfileKeyForEntry(entry);
        const profile = getAudioProfile(profileKey);
        if (entry.mode === 'dictation-text') {
            speakTextWithPauses(entry.text, lang, profile);
            return;
        }
        if (entry.mode === 'dictation') {
            speakSentenceWithPauses(entry.sentence, lang, profile);
            return;
        }
        // If card has a sentence, speak word then sentence for context
        if (card.sentence && card.sentence.trim() !== '') {
            speakWordWithSentence(card.word, card.sentence, lang, profile);
        } else {
            speak(card.word, lang, profile);
        }
    }
}

function checkAnswer() {
    const input = document.getElementById('p-input');
    const userRaw = input.value.trim();
    const entry = currentSession.currentEntry;
    if (entry && entry.mode === 'dictation-text') {
        checkDictationTextAnswer(userRaw);
        return;
    }
    if (entry && entry.mode === 'dictation') {
        checkDictationAnswer(userRaw);
        return;
    }
    const userValLower = userRaw.toLowerCase();
    const correctRaw = currentSession.currentCard.word;
    const correctLower = correctRaw.toLowerCase();
    // Determine correctness based on strictness
    let isCorrect = false;
    if (app.settings.strictness === 'strict') {
        isCorrect = userRaw === correctRaw;
    } else {
        isCorrect = userValLower === correctLower;
    }
    currentSession.isAnswered = true;
    currentSession.lastAnswerCorrect = isCorrect;
    document.getElementById('btn-check').classList.add('hidden');
    input.disabled = true;
    const feedback = document.getElementById('feedback');
    const positiveFeedback = [
        'Nice work!',
        'Great job!',
        'You got it!',
        'Nailed it!',
        'Smooth!'
    ];
    const extraPraise = positiveFeedback[Math.floor(Math.random() * positiveFeedback.length)];
    // Update performance statistics
    const card = currentSession.currentCard;
    const now = Date.now();
    let elapsed = 0;
    if (currentSession.startTime) {
        elapsed = (now - currentSession.startTime) / 1000;
    }
    // Compute average time (running average)
    const prevAttempts = (card.correctCount || 0) + (card.incorrectCount || 0);
    if (prevAttempts === 0) {
        card.avgTime = elapsed;
    } else {
        card.avgTime = ((card.avgTime || 0) * prevAttempts + elapsed) / (prevAttempts + 1);
    }
    if (isCorrect) {
        card.correctCount = (card.correctCount || 0) + 1;
    } else {
        card.incorrectCount = (card.incorrectCount || 0) + 1;
    }
    currentSession.totalAttempts += 1;
    if (isCorrect) {
        currentSession.correctAttempts += 1;
    } else {
        currentSession.troubleEntries.push(currentSession.currentEntry);
    }
    saveData();
    // Provide feedback
    if (isCorrect) {
        input.style.color = 'var(--success)';
        feedback.innerHTML = `
            <div class="feedback-positive">Correct!</div>
            <div class="feedback-sub">${extraPraise}</div>
        `;
        document.getElementById('srs-area').classList.remove('hidden');
    } else {
        input.style.color = 'var(--error)';
        const typedValue = input.value ? input.value : '';
        const diffMarkup = getWordDiffMarkup(currentSession.currentCard.word, typedValue, app.settings.strictness);
        feedback.innerHTML = `
            <div class="diff-display">
                <span class="diff-line">${diffMarkup}</span>
            </div>
            <div class="feedback-sub">Correct spelling with mistakes highlighted in red.</div>
            <div class="try-again-wrap">
                <button class="btn-secondary" onclick="retryCurrentCard()">Try again</button>
            </div>
        `;
    }
}

function checkDictationAnswer(userRaw) {
    const input = document.getElementById('p-input');
    const entry = currentSession.currentEntry;
    if (!entry) return;
    const correctSentence = entry.sentence || '';
    const analysis = analyzeDictationErrors(correctSentence, userRaw);
    const isCorrect = isSentenceCorrect(correctSentence, userRaw, 'strict');
    currentSession.isAnswered = true;
    currentSession.lastAnswerCorrect = isCorrect;
    document.getElementById('btn-check').classList.add('hidden');
    input.disabled = true;
    const feedback = document.getElementById('feedback');
    const elapsed = getElapsedSeconds();
    const { mistakeCards, totalWords } = applyDictationSentenceStats(entry, userRaw, elapsed, 'strict');
    currentSession.totalAttempts += totalWords;
    if (mistakeCards.length) {
        currentSession.correctAttempts += Math.max(totalWords - mistakeCards.length, 0);
        mistakeCards.forEach(card => {
            currentSession.troubleEntries.push({ deck: entry.deck, card });
        });
    } else {
        currentSession.correctAttempts += totalWords;
    }
    if (entry.deck && isDictationDeck(entry.deck)) {
        entry.deck.dictationStatsReady = true;
    }
    saveData();
    if (isCorrect) {
        input.style.color = 'var(--success)';
        feedback.innerHTML = `
            <div class="feedback-positive">Sentence correct!</div>
            <div class="feedback-sub">Nice work finishing that dictation.</div>
            <div class="dictation-score">Score: <strong>100%</strong></div>
        `;
    } else {
        input.style.color = 'var(--error)';
        const diffMarkup = getSentenceDiffMarkup(correctSentence, userRaw, 'strict');
        const mistakeList = mistakeCards.map(card => card.word).join(', ');
        feedback.innerHTML = `
            <div class="diff-display">
                <span class="diff-line">${diffMarkup}</span>
            </div>
            <div class="feedback-sub">Review these words: <strong>${mistakeList || 'Check the sentence again'}</strong>.</div>
            <div class="dictation-score">Score: <strong>${analysis.score}%</strong></div>
            <ul class="dictation-error-list">${buildDictationErrorListMarkup(analysis)}</ul>
        `;
    }
    feedback.innerHTML += `
        <div class="try-again-wrap">
            <button class="btn-primary" onclick="advanceCurrentEntry()">Next sentence</button>
        </div>
    `;
}

function checkDictationTextAnswer(userRaw) {
    const input = document.getElementById('p-input');
    const entry = currentSession.currentEntry;
    if (!entry) return;
    const correctText = entry.text || '';
    const analysis = analyzeDictationErrors(correctText, userRaw);
    const isCorrect = isTextCorrect(correctText, userRaw, 'strict');
    currentSession.isAnswered = true;
    currentSession.lastAnswerCorrect = isCorrect;
    document.getElementById('btn-check').classList.add('hidden');
    input.disabled = true;
    const feedback = document.getElementById('feedback');
    const elapsed = getElapsedSeconds();
    const { mistakeCards, totalWords } = applyDictationTextStats(entry.deck, correctText, userRaw, elapsed, 'strict');
    if (entry.deck) {
        entry.deck.lastPracticed = Date.now();
        entry.deck.dictationStatsReady = true;
    }
    saveData();
    currentSession.totalAttempts += totalWords;
    if (isCorrect) {
        currentSession.correctAttempts += totalWords;
    } else {
        const wrongCount = Math.min(mistakeCards.length, totalWords);
        currentSession.correctAttempts += Math.max(totalWords - wrongCount, 0);
    }
    if (isCorrect) {
        input.style.color = 'var(--success)';
        feedback.innerHTML = `
            <div class="feedback-positive">Text correct!</div>
            <div class="feedback-sub">Great work completing the full dictation.</div>
            <div class="dictation-score">Score: <strong>100%</strong></div>
        `;
    } else {
        input.style.color = 'var(--error)';
        const diffMarkup = getSentenceDiffMarkup(correctText, userRaw, 'strict');
        feedback.innerHTML = `
            <div class="diff-display">
                <span class="diff-line">${diffMarkup}</span>
            </div>
            <div class="feedback-sub">Mistakes are highlighted in red. Focus on those words next.</div>
            <div class="dictation-score">Score: <strong>${analysis.score}%</strong></div>
            <ul class="dictation-error-list">${buildDictationErrorListMarkup(analysis)}</ul>
        `;
    }
    feedback.innerHTML += `
        <div class="try-again-wrap">
            <button class="btn-primary" onclick="advanceCurrentEntry()">Finish</button>
        </div>
    `;
    mistakeCards.forEach(card => {
        currentSession.troubleEntries.push({ deck: entry.deck, card });
    });
}

function advanceCurrentEntry() {
    if (!currentSession.currentEntry) return;
    currentSession.queue.shift();
    currentSession.completedCount += 1;
    nextCard();
}

function getElapsedSeconds() {
    const now = Date.now();
    if (!currentSession.startTime) return 0;
    return (now - currentSession.startTime) / 1000;
}

function retryCurrentCard() {
    const input = document.getElementById('p-input');
    const feedback = document.getElementById('feedback');
    if (!input || !feedback) return;
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    currentSession.startTime = app.settings.timerStart === 'show' ? Date.now() : null;
    input.disabled = false;
    input.value = '';
    input.style.color = 'var(--primary)';
    feedback.innerHTML = '';
    document.getElementById('btn-check').classList.remove('hidden');
    document.getElementById('srs-area').classList.add('hidden');
    input.focus();
}

function rateCard(quality) {
    const card = currentSession.currentCard;
    const entry = currentSession.currentEntry;
    
    // Simple SRS Logic
    if (quality < 3) {
        card.interval = 1;
        card.ease = Math.max(1.3, card.ease - 0.2);
    } else {
        if (card.interval === 0) card.interval = 1;
        else if (card.interval === 1) card.interval = 3;
        else card.interval = Math.ceil(card.interval * card.ease);
        
        card.ease = card.ease + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        if (card.ease < 1.3) card.ease = 1.3;
    }

    // Set Due Date
    const DAY_MS = 86400000;
    card.due = Date.now() + (quality < 3 ? 0 : card.interval * DAY_MS);

    if (entry && entry.deck) {
        entry.deck.lastPracticed = Date.now();
    }
    saveData();
    
    currentSession.queue.shift(); // Remove current
    const shouldRequeue = quality < 3 || currentSession.lastAnswerCorrect === false || quality === 1;
    if (shouldRequeue) {
        currentSession.queue.unshift(entry); // Re-queue immediately
    } else {
        currentSession.completedCount += 1;
    }
    
    nextCard();
}

// --- DECK MANAGEMENT ---
function renderDeckList() {
    const list = document.getElementById('deck-list');
    list.innerHTML = '';
    const filteredDecks = getFilteredDecks();
    
    if (app.decks.length === 0) {
        list.innerHTML = `<div style="text-align:center; padding:var(--space-4); color:var(--text-sub);">
            No packs yet.<br>Click "+ New Pack" to create one.
        </div>`;
        return;
    }
    if (filteredDecks.length === 0) {
        list.innerHTML = `<div style="text-align:center; padding:var(--space-4); color:var(--text-sub);">
            No packs match this language filter.
        </div>`;
        return;
    }

    filteredDecks.forEach(deck => {
        const dueCount = getDueCount(deck);
        const dictationLabel = isDictationDeck(deck) ? ' ‚Ä¢ Dictation text' : '';
        const div = document.createElement('div');
        div.className = 'deck-item';
        div.innerHTML = `
            <div class="deck-info">
                <h3>${deck.name}</h3>
                <small>${deck.lang} ‚Ä¢ ${deck.cards.length} cards ‚Ä¢ ${dueCount} due${dictationLabel}</small>
            </div>
            <div style="display:flex; gap:8px;">
                <button class="btn-secondary" onclick="openDeckActions('${deck.id}')">Edit</button>
                <button class="btn-primary" onclick="openPracticeOptionsModal('${deck.id}')">Practice</button>
            </div>
        `;
        list.appendChild(div);
    });
    updateLanguageFilterOptions();
}

// --- PROGRESS RENDERING ---
function renderProgress() {
    const overviewEl = document.getElementById('progress-overview');
    const detailsEl = document.getElementById('progress-details');
    if (!overviewEl || !detailsEl) return;
    overviewEl.innerHTML = '';
    detailsEl.innerHTML = '';
    progressTroubleEntries = [];
    const filteredDecks = getFilteredDecks();
    if (app.decks.length === 0) {
        overviewEl.innerHTML = '<div style="padding:var(--space-2); color:var(--text-sub); text-align:center;">No data yet.</div>';
        return;
    }
    if (filteredDecks.length === 0) {
        overviewEl.innerHTML = '<div style="padding:var(--space-2); color:var(--text-sub); text-align:center;">No data for this language filter.</div>';
        return;
    }
    let total = 0;
    let mastered = 0;
    let dueTotal = 0;
    const troubleList = [];
    const now = Date.now();
    filteredDecks.forEach(deck => {
        deck.cards.forEach(card => {
            total++;
            if (card.due <= now) {
                dueTotal++;
            }
            if (card.interval > 15) {
                mastered++;
            }
            troubleList.push({
                word: card.word,
                deck: deck.name,
                deckRef: deck,
                cardRef: card,
                incorrect: card.incorrectCount || 0,
                avgTime: card.avgTime || 0
            });
        });
    });
    const masteryPercent = total ? Math.round((mastered / total) * 100) : 0;
    const troubleCandidates = troubleList.filter(item => item.incorrect > 0 || item.avgTime > 0);
    const troubleCount = troubleCandidates.length;
    let overviewHTML = `
        <h3 style="margin-top:0;">Mastery</h3>
        <div class="progress-metrics">
            <div class="progress-metric">
                <div class="progress-metric-label">Mastered</div>
                <div class="progress-metric-value">${masteryPercent}%</div>
            </div>
            <div class="progress-metric">
                <div class="progress-metric-label">Due today</div>
                <div class="progress-metric-value">${dueTotal}</div>
            </div>
            <div class="progress-metric">
                <div class="progress-metric-label">Trouble count</div>
                <div class="progress-metric-value">${troubleCount}</div>
            </div>
        </div>
    `;
    overviewEl.innerHTML = overviewHTML;
    // Trouble words
    troubleCandidates.sort((a,b) => {
        if (b.incorrect !== a.incorrect) return b.incorrect - a.incorrect;
        return b.avgTime - a.avgTime;
    });
    const topTrouble = troubleCandidates.slice(0,5);
    progressTroubleEntries = topTrouble.map(item => ({ deck: item.deckRef, card: item.cardRef }));
    let detailsHTML = '<h3 style="margin-top:0;">Trouble words</h3>';
    detailsHTML += '<p class="text-small" style="color:var(--text-sub);">Tackle these to level up your mastery.</p>';
    if (topTrouble.length > 0) {
        detailsHTML += '<div class="progress-trouble-list">';
        topTrouble.forEach(item => {
            const avgTimeLabel = item.avgTime > 0 ? `${item.avgTime.toFixed(1)}s` : '‚Äî';
            detailsHTML += `
                <div class="progress-trouble-item">
                    <div>
                        <strong>${item.word}</strong>
                        <div class="text-small" style="color:var(--text-sub);">${item.deck} ‚Ä¢ ${item.incorrect} errors ‚Ä¢ Avg ${avgTimeLabel}</div>
                    </div>
                </div>
            `;
        });
        detailsHTML += '</div>';
    } else {
        detailsHTML += '<div class="text-small" style="color:var(--text-sub); margin-bottom:var(--space-2);">No trouble words yet. Keep practicing!</div>';
    }
    detailsHTML += `<button class="btn-primary" onclick="startProgressTroublePractice()" ${topTrouble.length ? '' : 'disabled'}>Practice trouble words</button>`;
    detailsEl.innerHTML = detailsHTML;
}

// Modal Logic
let activeDeckIdForEdit = null;
let activeCardIndexForEdit = null;
function openDeckModal() {
    document.getElementById('deck-modal').classList.add('open');
    document.getElementById('new-deck-name').value = '';
    document.getElementById('new-deck-text').value = '';
    showDeckPanel('create');
}
function closeDeckModal() {
    document.getElementById('deck-modal').classList.remove('open');
}
function showDeckPanel(panel) {
    const createToggle = document.getElementById('deck-toggle-create');
    const importToggle = document.getElementById('deck-toggle-import');
    const createPanel = document.getElementById('deck-panel-create');
    const importPanel = document.getElementById('deck-panel-import');
    if (panel === 'import') {
        createToggle.classList.remove('active');
        importToggle.classList.add('active');
        createPanel.classList.add('hidden');
        importPanel.classList.remove('hidden');
    } else {
        importToggle.classList.remove('active');
        createToggle.classList.add('active');
        importPanel.classList.add('hidden');
        createPanel.classList.remove('hidden');
    }
}
function triggerDeckImport() {
    document.getElementById('import-deck-file').click();
}
function focusDeckPaste() {
    const textArea = document.getElementById('import-deck-json');
    if (!textArea) return;
    textArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
    textArea.focus();
}
function importDeckFromPaste() {
    const textArea = document.getElementById('import-deck-json');
    if (!textArea) return;
    const raw = textArea.value.trim();
    if (!raw) {
        alert("Paste pack JSON first.");
        return;
    }
    try {
        const data = JSON.parse(raw);
        const decks = normalizeImportedDecks(data);
        if (!decks.length) {
            alert("Invalid pack JSON");
            return;
        }
        app.decks.push(...decks);
        saveData();
        renderDeckList();
        textArea.value = '';
        closeDeckModal();
    } catch (err) {
        alert("Invalid pack JSON");
    }
}
function buildCardEntry(word, sentence = '') {
    return {
        word: word.trim(),
        sentence: sentence.trim(),
        audioUrl: '',
        due: 0,
        interval: 0,
        ease: 2.5,
        correctCount: 0,
        incorrectCount: 0,
        avgTime: 0
    };
}

function parseDeckTextInput(raw) {
    const input = raw.trim();
    if (!input) return { text: '', cards: [], usedList: false };
    const hasPairPattern = /[^,;]+?\s*[-:/=]\s*[^,;]+/;
    const hasSeparators = /[,;]/;
    const hasSentencePunct = /[.!?]/;
    if (hasPairPattern.test(input) || (hasSeparators.test(input) && !hasSentencePunct.test(input))) {
        const segments = input.split(/[;,]+/);
        const cards = [];
        segments.forEach(segment => {
            const trimmed = segment.trim();
            if (!trimmed) return;
            const pairMatch = trimmed.match(/^(.+?)\s*[-:/=]\s*(.+)$/);
            const word = pairMatch ? pairMatch[1].trim() : trimmed;
            const sentence = pairMatch ? pairMatch[2].trim() : '';
            if (word) cards.push(buildCardEntry(word, sentence));
        });
        return { text: '', cards, usedList: true };
    }
    return { text: input, cards: [], usedList: false };
}

function saveDeck() {
    const name = document.getElementById('new-deck-name').value;
    const lang = document.getElementById('new-deck-lang').value;
    const rawInput = document.getElementById('new-deck-text').value;
    const parsedInput = parseDeckTextInput(rawInput);
    if (!name) return;
    
    app.decks.push({
        id: generateDeckId(),
        name,
        lang,
        cards: parsedInput.cards,
        uncompleted: false,
        lastPracticed: null,
        text: parsedInput.text,
        dictationStatsReady: false
    });
    saveData();
    closeDeckModal();
    renderDeckList();
}

function manageCards(deckId) {
    activeDeckIdForEdit = deckId;
    document.getElementById('cards-modal').classList.add('open');
    renderDictationEditor();
    renderCardList();
}
function closeCardsModal() {
    document.getElementById('cards-modal').classList.remove('open');
    closeCardEditModal();
}

function renderDictationEditor() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    const panel = document.getElementById('dictation-text-panel');
    const textArea = document.getElementById('edit-deck-text-inline');
    if (!panel || !textArea) return;
    if (deck && deck.text && deck.text.trim()) {
        panel.style.display = 'block';
        textArea.value = deck.text || '';
    } else {
        panel.style.display = 'none';
        textArea.value = '';
    }
}

function updateDeckTextAndCards(deck, newText, shouldSync = true) {
    if (!deck) return;
    const trimmed = newText.trim();
    const prevText = (deck.text || '').trim();
    deck.text = trimmed;
    if (trimmed && (shouldSync || trimmed !== prevText)) {
        syncCardsWithDictationText(deck, trimmed);
        deck.dictationStatsReady = false;
    } else if (!trimmed && prevText) {
        deck.dictationStatsReady = false;
    }
}

function syncCardsWithDictationText(deck, text) {
    const tokens = getWordTokensWithSentence(text);
    const uniqueTokens = [];
    const seen = new Set();
    tokens.forEach(token => {
        const normalized = normalizeToken(token.word, 'lenient');
        if (!normalized || seen.has(normalized)) return;
        seen.add(normalized);
        uniqueTokens.push({ word: token.word, sentence: token.sentence });
    });
    const existingMap = new Map();
    deck.cards.forEach(card => {
        existingMap.set(normalizeToken(card.word || '', 'lenient'), card);
    });
    const nextCards = uniqueTokens.map(token => {
        const normalized = normalizeToken(token.word, 'lenient');
        const existing = existingMap.get(normalized);
        if (existing) {
            existing.word = token.word;
            existing.sentence = token.sentence || existing.sentence || '';
            return existing;
        }
        return buildCardEntry(token.word, token.sentence);
    });
    deck.cards = nextCards;
}

function saveDictationText() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    const textInput = document.getElementById('edit-deck-text-inline');
    if (!deck || !textInput) return;
    const nextText = textInput.value || '';
    updateDeckTextAndCards(deck, nextText, true);
    saveData();
    renderDictationEditor();
    renderCardList();
    renderDeckList();
    renderPracticeHome();
    renderProgress();
    if (document.getElementById('view-deck-progress').classList.contains('active')) {
        renderDeckProgress(deck.id);
    }
}

function openDeckActions(deckId) {
    activeDeckIdForEdit = deckId;
    const deck = app.decks.find(d => d.id === deckId);
    document.getElementById('deck-actions-title').textContent = deck ? deck.name : 'Pack Actions';
    document.getElementById('deck-actions-modal').classList.add('open');
}

function closeDeckActionsModal() {
    document.getElementById('deck-actions-modal').classList.remove('open');
}

function openPracticeOptionsModal(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    if (!deck) return;
    activePracticeDeckId = deckId;
    selectedPracticeMode = null;
    renderPracticeOptions(deck);
    document.getElementById('practice-options-modal').classList.add('open');
}

function closePracticeOptionsModal() {
    document.getElementById('practice-options-modal').classList.remove('open');
    activePracticeDeckId = null;
    selectedPracticeMode = null;
}

function renderPracticeOptions(deck) {
    const listEl = document.getElementById('practice-options-list');
    const titleEl = document.getElementById('practice-options-title');
    const noteEl = document.getElementById('practice-options-note');
    const startBtn = document.getElementById('practice-options-start');
    if (!listEl || !titleEl || !noteEl || !startBtn) return;
    titleEl.textContent = deck ? `${deck.name} practice` : 'Practice options';
    listEl.innerHTML = '';
    const options = getDeckPracticeOptions(deck);
    if (!options.length) {
        listEl.innerHTML = '<div class="text-small" style="color: var(--text-sub);">No practice options available yet.</div>';
        noteEl.textContent = '';
        startBtn.disabled = true;
        return;
    }
    options.forEach(option => {
        const div = document.createElement('div');
        div.className = 'practice-option';
        if (!option.available) div.classList.add('disabled');
        div.innerHTML = `
            <div class="practice-option-title">${option.label}</div>
            <div class="practice-option-desc">${option.description}</div>
        `;
        if (option.available) {
            div.addEventListener('click', () => {
                selectedPracticeMode = option.mode;
                renderPracticeOptions(deck);
            });
        }
        if (selectedPracticeMode === option.mode) {
            div.classList.add('selected');
        }
        listEl.appendChild(div);
    });
    const lockedOption = options.find(option => !option.available && option.reason);
    noteEl.textContent = lockedOption ? lockedOption.reason : '';
    startBtn.disabled = !selectedPracticeMode;
}

function startPracticeFromOptions() {
    if (!activePracticeDeckId || !selectedPracticeMode) return;
    const deck = app.decks.find(d => d.id === activePracticeDeckId);
    if (!deck) return;
    const entries = buildPracticeEntriesForMode(deck, selectedPracticeMode);
    if (!entries.length) {
        alert("No practice items available for this selection.");
        return;
    }
    closePracticeOptionsModal();
    startPracticeEntries(entries, [deck]);
}

function openDeckEditor() {
    closeDeckActionsModal();
    if (activeDeckIdForEdit) manageCards(activeDeckIdForEdit);
}

function openDeckStats() {
    closeDeckActionsModal();
    if (activeDeckIdForEdit) renderDeckProgress(activeDeckIdForEdit);
}

function openDeckMetaEditor() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    document.getElementById('edit-deck-name').value = deck.name || '';
    document.getElementById('edit-deck-lang').value = deck.lang || 'en-US';
    document.getElementById('edit-deck-text').value = deck.text || '';
    closeDeckActionsModal();
    document.getElementById('deck-meta-modal').classList.add('open');
}

function closeDeckMetaModal() {
    document.getElementById('deck-meta-modal').classList.remove('open');
}

function saveDeckMeta() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    const nameInput = document.getElementById('edit-deck-name');
    const langSelect = document.getElementById('edit-deck-lang');
    const textInput = document.getElementById('edit-deck-text');
    const newName = nameInput.value.trim();
    const newText = textInput.value;
    if (!newName) {
        alert("Pack name can't be empty.");
        return;
    }
    deck.name = newName;
    deck.lang = langSelect.value;
    updateDeckTextAndCards(deck, newText, true);
    saveData();
    closeDeckMetaModal();
    renderDeckList();
    renderPracticeHome();
    renderProgress();
    if (document.getElementById('view-deck-progress').classList.contains('active')) {
        renderDeckProgress(deck.id);
    }
}

function clearDeckCompletion(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    if (deck) deck.uncompleted = false;
    if (Array.isArray(currentSession.decks)) {
        currentSession.decks.forEach(sessionDeck => {
            if (sessionDeck.id === deckId) sessionDeck.uncompleted = false;
        });
    }
    if (Array.isArray(currentSession.queue)) {
        currentSession.queue.forEach(entry => {
            if (entry.deck && entry.deck.id === deckId) {
                entry.deck.uncompleted = false;
            }
        });
    }
}

function resetDeckStats() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    if (!confirm(`Reset stats for "${deck.name}"? This will mark all words as new.`)) return;
    deck.cards.forEach(card => {
        card.due = 0;
        card.interval = 0;
        card.ease = 2.5;
        card.correctCount = 0;
        card.incorrectCount = 0;
        card.avgTime = 0;
    });
    clearDeckCompletion(deck.id);
    saveData();
    renderDeckProgress(deck.id);
    renderProgress();
    if (!currentSession.isActive && document.getElementById('view-practice').classList.contains('active')) {
        renderPracticeHome();
    }
}

function exportDeck() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    const str = JSON.stringify(deck, null, 2);
    const blob = new Blob([str], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const safeName = deck.name ? deck.name.replace(/[^a-z0-9-_]+/gi, '_') : 'deck';
    a.href = url;
    a.download = `${safeName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function deleteDeck() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    if (!confirm(`Delete "${deck.name}"? This cannot be undone.`)) return;
    app.decks = app.decks.filter(d => d.id !== activeDeckIdForEdit);
    currentSession.selectedDeckIds = currentSession.selectedDeckIds.filter(id => id !== activeDeckIdForEdit);
    saveData();
    closeDeckActionsModal();
    renderDeckList();
    if (currentSession.deck && currentSession.deck.id === activeDeckIdForEdit) {
        currentSession.deck = null;
        currentSession.queue = [];
    }
    activeDeckIdForEdit = null;
}

function renderCardList() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    const container = document.getElementById('cards-list-content');
    container.innerHTML = '';
    
    if(deck.cards.length === 0) {
        container.innerHTML = '<div style="text-align:center; color:#999; padding:var(--space-3);">No cards yet</div>';
        return;
    }

    deck.cards.slice().reverse().forEach((card, index) => {
        const div = document.createElement('div');
        div.style = "display:flex; justify-content:space-between; align-items:center; padding: var(--space-2) 0; border-bottom:1px solid #f3f4f6;";
        const realIndex = deck.cards.length - 1 - index;
        div.innerHTML = `
            <div>
                <strong style="font-size:1.1rem;">${card.word}</strong>
                ${card.sentence ? `<div style="font-size:0.85rem; color:#666; margin-top:4px;">${card.sentence}</div>` : ''}
            </div>
            <div style="display:flex; gap:6px; align-items:center;">
                <button class="btn-icon" style="background:#e0e7ff; color:var(--primary-dark); width:32px; height:32px;" onclick="openCardEditor(${realIndex})">‚úé</button>
                <button class="btn-icon" style="background:#fee2e2; color:var(--error); width:32px; height:32px;" onclick="deleteCard(${realIndex})">‚úï</button>
            </div>
        `;
        container.appendChild(div);
    });
}

function openCardEditor(index) {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck || !deck.cards[index]) return;
    const card = deck.cards[index];
    activeCardIndexForEdit = index;
    document.getElementById('edit-card-word').value = card.word || '';
    document.getElementById('edit-card-sentence').value = card.sentence || '';
    document.getElementById('edit-card-audio').value = card.audioUrl || '';
    document.getElementById('card-edit-modal').classList.add('open');
}

function closeCardEditModal() {
    document.getElementById('card-edit-modal').classList.remove('open');
    activeCardIndexForEdit = null;
}

function saveCardEdits() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck || activeCardIndexForEdit === null) return;
    const wordInput = document.getElementById('edit-card-word');
    const sentenceInput = document.getElementById('edit-card-sentence');
    const audioInput = document.getElementById('edit-card-audio');
    const nextWord = wordInput.value.trim();
    if (!nextWord) {
        alert("Word can't be empty.");
        return;
    }
    const card = deck.cards[activeCardIndexForEdit];
    card.word = nextWord;
    card.sentence = sentenceInput.value.trim();
    card.audioUrl = audioInput.value.trim();
    saveData();
    closeCardEditModal();
    renderCardList();
    renderDeckList();
    renderProgress();
    if (document.getElementById('view-deck-progress').classList.contains('active')) {
        renderDeckProgress(deck.id);
    }
}

function addCardToDeck() {
    const w = document.getElementById('new-card-word');
    const s = document.getElementById('new-card-sentence');
    const a = document.getElementById('new-card-audio');
    if (!w.value) return;
    
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    const entry = buildCardEntry(w.value.trim(), s.value.trim());
    entry.audioUrl = a.value.trim() || '';
    deck.cards.push(entry);
    w.value = '';
    s.value = '';
    a.value = '';
    w.focus();
    saveData();
    renderCardList();
    renderDeckList();
}

function handlePracticeKeydown(event) {
    if (event.key !== "Enter") return;
    if (!currentSession.isActive || !currentSession.currentCard) return;
    if (!currentSession.isAnswered) return;
    if (!currentSession.lastAnswerCorrect) return;
    event.preventDefault();
    const quality = currentSession.lastAnswerCorrect ? 3 : 2;
    rateCard(quality);
}

function initCardInputListeners() {
    const inputs = [
        document.getElementById('new-card-word'),
        document.getElementById('new-card-sentence'),
        document.getElementById('new-card-audio')
    ].filter(Boolean);
    inputs.forEach(input => {
        input.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter') return;
            event.preventDefault();
            addCardToDeck();
        });
    });
}

function deleteCard(index) {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    deck.cards.splice(index, 1);
    saveData();
    renderCardList();
    renderDeckList();
}

function renderDeckProgress(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    const overviewEl = document.getElementById('deck-progress-overview');
    const detailsEl = document.getElementById('deck-progress-details');
    const titleEl = document.getElementById('deck-progress-title');
    if (!deck || !overviewEl || !detailsEl || !titleEl) return;
    activeDeckIdForEdit = deckId;
    titleEl.textContent = `${deck.name} Progress`;
    overviewEl.innerHTML = '';
    detailsEl.innerHTML = '';
    if (deck.cards.length === 0) {
        overviewEl.innerHTML = '<div style="padding:var(--space-2); color:var(--text-sub); text-align:center;">No cards yet.</div>';
        navTo('deck-progress');
        return;
    }
    let total = 0;
    let newWords = 0;
    let learning = 0;
    let mastered = 0;
    let dueTotal = 0;
    let sumTime = 0;
    let countTime = 0;
    const troubleList = [];
    const now = Date.now();
    deck.cards.forEach(card => {
        total++;
        if (card.due <= now) {
            dueTotal++;
        }
        if (card.interval === 0) {
            newWords++;
        } else if (card.interval > 15) {
            mastered++;
        } else {
            learning++;
        }
        if (card.avgTime && card.avgTime > 0) {
            sumTime += card.avgTime;
            countTime++;
        }
        troubleList.push({
            word: card.word,
            deck: deck.name,
            incorrect: card.incorrectCount || 0,
            avgTime: card.avgTime || 0
        });
    });
    const avgTime = countTime > 0 ? (sumTime / countTime).toFixed(1) : 'N/A';
    let overviewHTML = '<table style="width:100%; border-collapse:collapse; font-size:0.95rem;">';
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Total words</th><td style="padding:8px 4px; text-align:right;">${total}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Due</th><td style="padding:8px 4px; text-align:right;">${dueTotal}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">New</th><td style="padding:8px 4px; text-align:right;">${newWords}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Learning</th><td style="padding:8px 4px; text-align:right;">${learning}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Mastered</th><td style="padding:8px 4px; text-align:right;">${mastered}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Average response time (s)</th><td style="padding:8px 4px; text-align:right;">${avgTime}</td></tr>`;
    overviewHTML += '</table>';
    overviewEl.innerHTML = overviewHTML;
    troubleList.sort((a,b) => {
        if (b.incorrect !== a.incorrect) return b.incorrect - a.incorrect;
        return b.avgTime - a.avgTime;
    });
    const topTrouble = troubleList.filter(t => t.incorrect > 0 || t.avgTime > 0).slice(0,10);
    if (topTrouble.length > 0) {
        let detailsHTML = '<h3 style="margin-top:0;">Trouble Words</h3>';
        detailsHTML += '<table style="width:100%; border-collapse:collapse; font-size:0.9rem;">';
        detailsHTML += '<tr><th style="text-align:left; padding:4px;">Word</th><th style="text-align:left; padding:4px;">Errors</th><th style="text-align:right; padding:4px;">Avg time (s)</th></tr>';
        topTrouble.forEach(item => {
            detailsHTML += `<tr><td style="padding:4px;">${item.word}</td><td style="padding:4px;">${item.incorrect}</td><td style="padding:4px; text-align:right;">${item.avgTime.toFixed ? item.avgTime.toFixed(1) : item.avgTime}</td></tr>`;
        });
        detailsHTML += '</table>';
        detailsEl.innerHTML = detailsHTML;
    } else {
        detailsEl.innerHTML = '<div style="padding:var(--space-2); color:var(--text-sub);">No trouble words yet. Keep practicing!</div>';
    }
    navTo('deck-progress');
}

// --- UTILS & INIT ---
function generateDeckId() {
    return `deck-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function getDueCount(deck, now = Date.now()) {
    if (!deck || !Array.isArray(deck.cards)) return 0;
    return deck.cards.filter(card => card.due <= now).length;
}

function getTodayCounts(now = Date.now()) {
    let dueCount = 0;
    let newCount = 0;
    let troubleCount = 0;
    let totalCards = 0;
    const filteredDecks = getFilteredDecks();
    filteredDecks.forEach(deck => {
        deck.cards.forEach(card => {
            totalCards++;
            if (card.due <= now) dueCount++;
            if (card.interval === 0) newCount++;
            if ((card.incorrectCount || 0) > 0) troubleCount++;
        });
    });
    return { dueCount, newCount, troubleCount, totalCards };
}

function getTodayEntries(now = Date.now()) {
    const selectedDecks = getFilteredDecks();
    let entries = selectedDecks.flatMap(deck => {
        if (isDictationDeck(deck) && !deckHasDictationStats(deck)) {
            return buildDictationTextEntry(deck);
        }
        if (isDictationDeck(deck)) {
            return buildDictationEntries(deck);
        }
        return buildWordEntries(deck, now, true);
    }).sort((a, b) => {
        if (a.mode === 'dictation' || b.mode === 'dictation') return 0;
        if (a.mode === 'dictation-text' || b.mode === 'dictation-text') return 0;
        return a.card.due - b.card.due;
    });

    if (entries.length === 0) {
        entries = selectedDecks.flatMap(deck => {
            if (isDictationDeck(deck) && !deckHasDictationStats(deck)) {
                return buildDictationTextEntry(deck);
            }
            if (isDictationDeck(deck)) {
                return buildDictationEntries(deck);
            }
            return buildWordEntries(deck, now, false);
        });
    }

    return entries;
}

function formatPracticePreviewEntry(entry) {
    const pack = escapeHtml(entry.deck?.name || 'Unknown pack');
    if (entry.mode === 'dictation-text') {
        const text = truncatePreviewText(entry.text || 'Dictation text');
        return { type: 'Text', text: escapeHtml(text), pack };
    }
    if (entry.mode === 'dictation') {
        const text = truncatePreviewText(entry.sentence || 'Dictation sentence');
        return { type: 'Sentence', text: escapeHtml(text), pack };
    }
    const word = entry.card?.word || 'Word';
    return { type: 'Word', text: escapeHtml(word), pack };
}

function truncatePreviewText(text, limit = 80) {
    const safeText = String(text || '').trim();
    if (safeText.length <= limit) return safeText;
    return `${safeText.slice(0, limit - 1)}‚Ä¶`;
}

function createSampleDeck() {
    return {
        id: generateDeckId(),
        name: "Sample English",
        lang: "en-US",
        uncompleted: false,
        lastPracticed: null,
        text: '',
        dictationStatsReady: false,
        cards: [
            {word: "necessary", sentence: "It is necessary to sleep well.", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "queue", sentence: "Wait in the queue.", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "apple", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "banana", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "books", sentence: "I forgot my books at home", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "school", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0}
        ]
    };
}

function formatLastPracticed(timestamp) {
    if (!timestamp) return 'Never';
    const date = new Date(timestamp);
    if (Number.isNaN(date.getTime())) return 'Never';
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
}

function isDictationDeck(deck) {
    return Boolean(deck && deck.text && deck.text.trim());
}

function deckHasDictationStats(deck) {
    if (!deck) return false;
    if (deck.dictationStatsReady) return true;
    return deck.cards.some(card => (card.correctCount || 0) + (card.incorrectCount || 0) > 0);
}

function getDeckPracticeOptions(deck) {
    if (!deck) return [];
    const hasWords = Array.isArray(deck.cards) && deck.cards.length > 0;
    const hasSentences = getDictationSentences(deck).length > 0;
    const hasText = isDictationDeck(deck);
    const statsReady = !hasText || deckHasDictationStats(deck);
    const options = [
        {
            mode: 'word',
            label: 'Practice words',
            description: 'Spell individual words with sentence hints.',
            show: hasWords,
            available: hasWords && statsReady
        },
        {
            mode: 'sentence',
            label: 'Practice sentences',
            description: 'Type each sentence from the dictation.',
            show: hasSentences,
            available: hasSentences && statsReady
        },
        {
            mode: 'text',
            label: 'Practice full text',
            description: 'Dictation of the entire text in one go.',
            show: hasText,
            available: hasText
        }
    ];
    if (hasText && !statsReady) {
        options.forEach(option => {
            if (option.mode !== 'text') {
                option.available = false;
                option.reason = 'Complete the full text once to unlock word and sentence practice.';
            }
        });
    }
    return options.filter(option => option.show);
}

function buildPracticeEntriesForMode(deck, mode) {
    const now = Date.now();
    if (mode === 'word') {
        const dueEntries = buildWordEntries(deck, now, true);
        return dueEntries.length ? dueEntries : buildWordEntries(deck, now, false);
    }
    if (mode === 'sentence') {
        return buildDictationEntries(deck);
    }
    if (mode === 'text') {
        return buildDictationTextEntry(deck);
    }
    return [];
}

function splitTextIntoSentences(text) {
    if (!text) return [];
    const matches = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g);
    return matches ? matches.map(sentence => sentence.trim()).filter(Boolean) : [];
}

function getDictationSentences(deck) {
    const sentences = splitTextIntoSentences(deck.text || '');
    if (sentences.length) return sentences;
    const unique = [];
    const seen = new Set();
    deck.cards.forEach(card => {
        const sentence = (card.sentence || '').trim();
        if (sentence && !seen.has(sentence)) {
            seen.add(sentence);
            unique.push(sentence);
        }
    });
    return unique;
}

function buildDictationEntries(deck) {
    const sentences = getDictationSentences(deck);
    return sentences.map((sentence, index) => {
        const cards = deck.cards.filter(card => (card.sentence || '').trim() === sentence);
        return {
            deck,
            mode: 'dictation',
            sentence,
            sentenceIndex: index + 1,
            sentenceCount: sentences.length,
            cards,
            primaryCard: pickMostDifficultCard(cards)
        };
    }).filter(entry => entry.sentence);
}

function buildDictationTextEntry(deck) {
    if (!deck || !deck.text || !deck.text.trim()) return [];
    const sentences = splitTextIntoSentences(deck.text);
    return [{
        deck,
        mode: 'dictation-text',
        text: deck.text.trim(),
        sentenceCount: sentences.length
    }];
}

function buildWordEntries(deck, now = Date.now(), dueOnly = true) {
    if (!deck || !Array.isArray(deck.cards)) return [];
    const cards = dueOnly ? deck.cards.filter(card => card.due <= now) : deck.cards;
    return cards.map(card => ({ deck, card, mode: 'word' }));
}

function pickMostDifficultCard(cards) {
    if (!cards || !cards.length) return null;
    return cards.slice().sort((a, b) => {
        const aErrors = a.incorrectCount || 0;
        const bErrors = b.incorrectCount || 0;
        if (bErrors !== aErrors) return bErrors - aErrors;
        const aTime = a.avgTime || 0;
        const bTime = b.avgTime || 0;
        if (bTime !== aTime) return bTime - aTime;
        return (b.word || '').length - (a.word || '').length;
    })[0];
}

function tokenizeWords(text) {
    return text.match(/[\p{L}\p{N}']+/gu) || [];
}

function normalizeToken(token, strictness) {
    return strictness === 'strict' ? token : token.toLowerCase();
}

function escapeHtml(value) {
    const div = document.createElement('div');
    div.textContent = value;
    return div.innerHTML;
}

function getLcsMatchIndices(correctTokens, userTokens) {
    const m = correctTokens.length;
    const n = userTokens.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    for (let i = 1; i <= m; i += 1) {
        for (let j = 1; j <= n; j += 1) {
            if (correctTokens[i - 1] === userTokens[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    const matchIndices = new Set();
    let i = m;
    let j = n;
    while (i > 0 && j > 0) {
        if (correctTokens[i - 1] === userTokens[j - 1]) {
            matchIndices.add(i - 1);
            i -= 1;
            j -= 1;
        } else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i -= 1;
        } else {
            j -= 1;
        }
    }
    return matchIndices;
}

function getWordDiffMarkup(correctWord, userWord, strictness) {
    const correctChars = Array.from(correctWord || '');
    const userChars = Array.from(userWord || '');
    const normalizedCorrect = correctChars.map(char => normalizeToken(char, strictness));
    const normalizedUser = userChars.map(char => normalizeToken(char, strictness));
    const matchIndices = getLcsMatchIndices(normalizedCorrect, normalizedUser);
    return correctChars.map((char, index) => {
        const safeChar = escapeHtml(char);
        if (matchIndices.has(index)) {
            return `<span>${safeChar}</span>`;
        }
        return `<span class="diff-highlight">${safeChar}</span>`;
    }).join('');
}

function getSentenceDiffMarkup(correctSentence, userSentence, strictness) {
    const tokens = String(correctSentence || '').match(/[\p{L}\p{N}']+|[^\p{L}\p{N}']+/gu) || [];
    const correctWords = tokens.filter(token => /[\p{L}\p{N}']+/u.test(token)).map(token => normalizeToken(token, strictness));
    const userWordTokens = tokenizeWords(userSentence || '');
    const normalizedUser = userWordTokens.map(token => normalizeToken(token, strictness));
    const matchIndices = getLcsMatchIndices(correctWords, normalizedUser);
    let wordIndex = 0;
    return tokens.map(token => {
        if (/[\p{L}\p{N}']+/u.test(token)) {
            const isMatch = matchIndices.has(wordIndex);
            const safeToken = escapeHtml(token);
            wordIndex += 1;
            if (isMatch) return safeToken;
            if (userWordTokens.length === correctWords.length) {
                const userWord = userWordTokens[wordIndex - 1] || '';
                return getWordDiffMarkup(token, userWord, strictness);
            }
            return `<span class="diff-highlight">${safeToken}</span>`;
        }
        return escapeHtml(token);
    }).join('');
}

function getDictationTokens(text) {
    const tokens = String(text || '').match(/[\p{L}\p{N}']+|[^\p{L}\p{N}']+/gu) || [];
    return tokens.map(token => token.trim()).filter(Boolean).map(token => ({
        value: token,
        type: /[\p{L}\p{N}']+/u.test(token) ? 'word' : 'punct'
    }));
}

function getLcsMatches(correctTokens, userTokens) {
    const m = correctTokens.length;
    const n = userTokens.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    for (let i = 1; i <= m; i += 1) {
        for (let j = 1; j <= n; j += 1) {
            if (correctTokens[i - 1] === userTokens[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    const matches = [];
    let i = m;
    let j = n;
    while (i > 0 && j > 0) {
        if (correctTokens[i - 1] === userTokens[j - 1]) {
            matches.push({ correctIndex: i - 1, userIndex: j - 1 });
            i -= 1;
            j -= 1;
        } else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i -= 1;
        } else {
            j -= 1;
        }
    }
    return matches.reverse();
}

function isGrammarEndingMismatch(expectedWord, actualWord) {
    const expected = String(expectedWord || '').toLowerCase();
    const actual = String(actualWord || '').toLowerCase();
    if (!expected || !actual || expected === actual) return false;
    if (expected.startsWith(actual) || actual.startsWith(expected)) {
        const diff = Math.abs(expected.length - actual.length);
        return diff > 0 && diff <= 4;
    }
    const minStem = Math.min(expected.length, actual.length) - 2;
    if (minStem > 1 && expected.slice(0, minStem) === actual.slice(0, minStem)) {
        return true;
    }
    return false;
}

function analyzeDictationErrors(correctSentence, userSentence) {
    const expectedTokens = getDictationTokens(correctSentence);
    const actualTokens = getDictationTokens(userSentence);
    const expectedWords = expectedTokens.filter(token => token.type === 'word').map(token => token.value);
    const actualWords = actualTokens.filter(token => token.type === 'word').map(token => token.value);
    const expectedPunct = expectedTokens.filter(token => token.type === 'punct').map(token => token.value);
    const actualPunct = actualTokens.filter(token => token.type === 'punct').map(token => token.value);

    const normalizedExpected = expectedWords.map(word => word.toLowerCase());
    const normalizedActual = actualWords.map(word => word.toLowerCase());
    const wordMatches = getLcsMatches(normalizedExpected, normalizedActual);
    const matchedExpected = new Set(wordMatches.map(match => match.correctIndex));
    const matchedActual = new Set(wordMatches.map(match => match.userIndex));

    let capitalization = 0;
    wordMatches.forEach(match => {
        const expectedWord = expectedWords[match.correctIndex];
        const actualWord = actualWords[match.userIndex];
        if (expectedWord && actualWord && expectedWord !== actualWord && expectedWord.toLowerCase() === actualWord.toLowerCase()) {
            capitalization += 1;
        }
    });

    const unmatchedExpected = normalizedExpected.map((_, idx) => idx).filter(idx => !matchedExpected.has(idx));
    const unmatchedActual = normalizedActual.map((_, idx) => idx).filter(idx => !matchedActual.has(idx));

    const actualIndexMap = new Map();
    unmatchedActual.forEach(idx => {
        const word = normalizedActual[idx];
        if (!actualIndexMap.has(word)) actualIndexMap.set(word, []);
        actualIndexMap.get(word).push(idx);
    });

    let wordOrder = 0;
    const remainingExpected = [];
    const usedActualForOrder = new Set();
    unmatchedExpected.forEach(idx => {
        const word = normalizedExpected[idx];
        const pool = actualIndexMap.get(word);
        if (pool && pool.length) {
            const matchedIndex = pool.shift();
            usedActualForOrder.add(matchedIndex);
            wordOrder += 1;
        } else {
            remainingExpected.push(idx);
        }
    });
    const remainingActual = unmatchedActual.filter(idx => !usedActualForOrder.has(idx));

    let spelling = 0;
    let grammarEnding = 0;
    const remainingExpectedSet = new Set(remainingExpected);
    const remainingActualSet = new Set(remainingActual);
    const maxLen = Math.max(expectedWords.length, actualWords.length);
    for (let i = 0; i < maxLen; i += 1) {
        if (!remainingExpectedSet.has(i) || !remainingActualSet.has(i)) continue;
        const expectedWord = expectedWords[i];
        const actualWord = actualWords[i];
        if (!expectedWord || !actualWord) continue;
        if (expectedWord.toLowerCase() === actualWord.toLowerCase()) {
            if (expectedWord !== actualWord) {
                capitalization += 1;
            }
        } else if (isGrammarEndingMismatch(expectedWord, actualWord)) {
            grammarEnding += 1;
        } else {
            spelling += 1;
        }
        remainingExpectedSet.delete(i);
        remainingActualSet.delete(i);
    }

    const missingWord = remainingExpectedSet.size;
    const extraWord = remainingActualSet.size;

    const punctuationMatches = getLcsMatches(expectedPunct, actualPunct);
    const punctuationMissing = Math.max(expectedPunct.length - punctuationMatches.length, 0);
    const punctuationExtra = Math.max(actualPunct.length - punctuationMatches.length, 0);
    const punctuation = punctuationMissing + punctuationExtra;

    const totalErrors = spelling + capitalization + punctuation + grammarEnding + missingWord + extraWord + wordOrder;
    const totalUnits = expectedWords.length + expectedPunct.length || 1;
    const score = Math.max(0, Math.round(((totalUnits - totalErrors) / totalUnits) * 100));

    return {
        score,
        totalErrors,
        counts: {
            spelling,
            capitalization,
            punctuation,
            grammarEnding,
            missingWord,
            extraWord,
            wordOrder
        }
    };
}

function buildDictationErrorListMarkup(analysis) {
    const rows = [];
    const labels = [
        ['spelling', 'Spelling'],
        ['capitalization', 'Capitalization'],
        ['punctuation', 'Punctuation'],
        ['grammarEnding', 'Grammar ending'],
        ['missingWord', 'Missing word'],
        ['extraWord', 'Extra word'],
        ['wordOrder', 'Word order']
    ];
    labels.forEach(([key, label]) => {
        const count = analysis.counts[key] || 0;
        if (count > 0) {
            rows.push(`<li><span>${label}</span><strong>${count}</strong></li>`);
        }
    });
    if (!rows.length) {
        return '<li><span>Perfect sentence</span><strong>0</strong></li>';
    }
    return rows.join('');
}

function isSentenceCorrect(correctSentence, userSentence, strictness) {
    if (strictness === 'strict') {
        return correctSentence.trim() === userSentence.trim();
    }
    const correctTokens = tokenizeWords(correctSentence).map(token => token.toLowerCase());
    const userTokens = tokenizeWords(userSentence).map(token => token.toLowerCase());
    if (correctTokens.length !== userTokens.length) return false;
    return correctTokens.every((token, index) => token === userTokens[index]);
}

function isTextCorrect(correctText, userText, strictness) {
    if (strictness === 'strict') {
        return correctText.trim() === userText.trim();
    }
    const correctTokens = tokenizeWords(correctText).map(token => token.toLowerCase());
    const userTokens = tokenizeWords(userText).map(token => token.toLowerCase());
    if (correctTokens.length !== userTokens.length) return false;
    return correctTokens.every((token, index) => token === userTokens[index]);
}

function applyDictationSentenceStats(entry, userSentence, elapsedSeconds, strictness = 'strict') {
    if (!entry || !entry.deck) return { mistakeCards: [], totalWords: 0 };
    const correctTokens = tokenizeWords(entry.sentence || '');
    const normalizedCorrect = correctTokens.map(token => normalizeToken(token, strictness));
    const normalizedUser = tokenizeWords(userSentence).map(token => normalizeToken(token, strictness));
    const matchIndices = getLcsMatchIndices(normalizedCorrect, normalizedUser);
    const mistakeCards = [];
    correctTokens.forEach((token, index) => {
        const card = getOrCreateCardForWord(entry.deck, token, entry.sentence);
        const isCorrect = matchIndices.has(index);
        applyDictationRating(card, entry.deck, elapsedSeconds, isCorrect);
        if (!isCorrect) {
            mistakeCards.push(card);
        }
    });
    entry.deck.dictationStatsReady = true;
    return { mistakeCards, totalWords: correctTokens.length || 1 };
}

function getWordTokensWithSentence(text) {
    const sentences = splitTextIntoSentences(text || '');
    const tokens = [];
    sentences.forEach(sentence => {
        tokenizeWords(sentence).forEach(word => {
            tokens.push({ word, sentence });
        });
    });
    return tokens;
}

function getOrCreateCardForWord(deck, word, sentence) {
    const normalizedWord = normalizeToken(word, 'lenient');
    let card = deck.cards.find(item => normalizeToken(item.word || '', 'lenient') === normalizedWord);
    if (!card) {
        card = {
            word,
            sentence: sentence || '',
            audioUrl: '',
            due: 0,
            interval: 0,
            ease: 2.5,
            correctCount: 0,
            incorrectCount: 0,
            avgTime: 0
        };
        deck.cards.push(card);
    } else if (!card.sentence && sentence) {
        card.sentence = sentence;
    }
    return card;
}

function applyDictationTextStats(deck, correctText, userText, elapsedSeconds, strictness = 'strict') {
    if (!deck) return { mistakeCards: [], totalWords: 0 };
    const correctWordTokens = getWordTokensWithSentence(correctText);
    const normalizedCorrectWords = correctWordTokens.map(token => normalizeToken(token.word, strictness));
    const userWords = tokenizeWords(userText).map(token => normalizeToken(token, strictness));
    const matchIndices = getLcsMatchIndices(normalizedCorrectWords, userWords);
    const mistakeCards = [];
    correctWordTokens.forEach((token, index) => {
        const card = getOrCreateCardForWord(deck, token.word, token.sentence);
        const isCorrect = matchIndices.has(index);
        applyDictationRating(card, deck, elapsedSeconds, isCorrect);
        if (!isCorrect) {
            mistakeCards.push(card);
        }
    });
    deck.dictationStatsReady = true;
    return { mistakeCards, totalWords: correctWordTokens.length || 1 };
}

function applyDictationRating(card, deck, elapsedSeconds, isCorrect) {
    if (!card) return;
    const prevAttempts = (card.correctCount || 0) + (card.incorrectCount || 0);
    if (prevAttempts === 0) {
        card.avgTime = elapsedSeconds;
    } else {
        card.avgTime = ((card.avgTime || 0) * prevAttempts + elapsedSeconds) / (prevAttempts + 1);
    }
    if (isCorrect) {
        card.correctCount = (card.correctCount || 0) + 1;
        applySrsRating(card, 3);
    } else {
        card.incorrectCount = (card.incorrectCount || 0) + 1;
        applySrsRating(card, 1);
    }
    if (deck) {
        deck.lastPracticed = Date.now();
    }
}

function applySrsRating(card, quality) {
    card.interval = Number(card.interval) || 0;
    if (quality < 3) {
        card.interval = 1;
        card.ease = Math.max(1.3, (card.ease || 2.5) - 0.2);
    } else {
        if (card.interval === 0) card.interval = 1;
        else if (card.interval === 1) card.interval = 3;
        else card.interval = Math.ceil(card.interval * (card.ease || 2.5));
        card.ease = (card.ease || 2.5) + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        if (card.ease < 1.3) card.ease = 1.3;
    }
    const DAY_MS = 86400000;
    card.due = Date.now() + (quality < 3 ? 0 : card.interval * DAY_MS);
}

function normalizeImportedDecks(raw) {
    let decks = [];
    if (Array.isArray(raw)) {
        decks = raw;
    } else if (raw && Array.isArray(raw.decks)) {
        decks = raw.decks;
    } else if (raw && raw.name && Array.isArray(raw.cards)) {
        decks = [raw];
    }
    return decks.map((deck) => {
        const existingId = deck.id && !app.decks.some(d => d.id === deck.id);
        const normalizedCards = Array.isArray(deck.cards) ? deck.cards.map(card => ({
            word: String(card.word || '').trim(),
            sentence: card.sentence ? String(card.sentence) : '',
            audioUrl: card.audioUrl ? String(card.audioUrl) : '',
            due: Number(card.due) || 0,
            interval: Number(card.interval) || 0,
            ease: typeof card.ease === 'number' ? card.ease : 2.5,
            correctCount: Number(card.correctCount) || 0,
            incorrectCount: Number(card.incorrectCount) || 0,
            avgTime: Number(card.avgTime) || 0
        })).filter(card => card.word) : [];
        return {
            id: existingId ? deck.id : generateDeckId(),
            name: deck.name ? String(deck.name) : 'Imported Pack',
            lang: deck.lang ? String(deck.lang) : 'en-US',
            cards: normalizedCards,
            uncompleted: Boolean(deck.uncompleted),
            lastPracticed: deck.lastPracticed ? Number(deck.lastPracticed) : null,
            text: deck.text ? String(deck.text) : '',
            dictationStatsReady: Boolean(deck.dictationStatsReady)
        };
    });
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function initSettingsListeners() {
    const initAudioProfileSlider = (mode, inputId, valueId, settingKey, fallback) => {
        const input = document.getElementById(inputId);
        const valueEl = document.getElementById(valueId);
        if (!input || !valueEl) return;
        const profile = getAudioProfile(mode);
        const value = getProfileSetting(profile, settingKey, fallback);
        input.value = value;
        valueEl.textContent = value;
        input.addEventListener('input', (e) => {
            const nextValue = getPauseValue(e.target.value, fallback);
            setAudioProfileSetting(mode, settingKey, nextValue);
            valueEl.textContent = nextValue;
            saveData();
        });
    };

    initAudioProfileSlider('dictationText', 'setting-speed-text', 'speed-text-val', 'speed', AUDIO_PROFILE_DEFAULTS.speed);
    initAudioProfileSlider('dictationText', 'setting-pause-start-text', 'pause-start-text-val', 'pauseStartMs', AUDIO_PROFILE_DEFAULTS.pauseStartMs);
    initAudioProfileSlider('dictationText', 'setting-pause-between-sentences-text', 'pause-between-sentences-text-val', 'pauseBetweenSentencesMs', AUDIO_PROFILE_DEFAULTS.pauseBetweenSentencesMs);
    initAudioProfileSlider('dictationText', 'setting-pause-mid-sentence-text', 'pause-mid-sentence-text-val', 'pauseMidSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseMidSentenceMs);
    initAudioProfileSlider('dictationText', 'setting-pause-two-words-text', 'pause-two-words-text-val', 'pauseTwoWordsMs', AUDIO_PROFILE_DEFAULTS.pauseTwoWordsMs);

    initAudioProfileSlider('sentence', 'setting-speed-sentence', 'speed-sentence-val', 'speed', AUDIO_PROFILE_DEFAULTS.speed);
    initAudioProfileSlider('sentence', 'setting-pause-start-sentence', 'pause-start-sentence-val', 'pauseStartMs', AUDIO_PROFILE_DEFAULTS.pauseStartMs);
    initAudioProfileSlider('sentence', 'setting-pause-mid-sentence-sentence', 'pause-mid-sentence-sentence-val', 'pauseMidSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseMidSentenceMs);
    initAudioProfileSlider('sentence', 'setting-pause-two-words-sentence', 'pause-two-words-sentence-val', 'pauseTwoWordsMs', AUDIO_PROFILE_DEFAULTS.pauseTwoWordsMs);

    initAudioProfileSlider('word', 'setting-speed-word', 'speed-word-val', 'speed', AUDIO_PROFILE_DEFAULTS.speed);
    initAudioProfileSlider('word', 'setting-pause-start-word', 'pause-start-word-val', 'pauseStartMs', AUDIO_PROFILE_DEFAULTS.pauseStartMs);
    initAudioProfileSlider('word', 'setting-pause-word-sentence-word', 'pause-word-sentence-word-val', 'pauseWordSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseWordSentenceMs);
    initAudioProfileSlider('word', 'setting-pause-mid-sentence-word', 'pause-mid-sentence-word-val', 'pauseMidSentenceMs', AUDIO_PROFILE_DEFAULTS.pauseMidSentenceMs);
    initAudioProfileSlider('word', 'setting-pause-two-words-word', 'pause-two-words-word-val', 'pauseTwoWordsMs', AUDIO_PROFILE_DEFAULTS.pauseTwoWordsMs);

    document.querySelectorAll('.settings-toggle').forEach((btn) => {
        const panelId = btn.getAttribute('data-panel');
        const panel = panelId ? document.getElementById(panelId) : null;
        if (!panel) return;
        btn.setAttribute('aria-expanded', 'false');
        btn.addEventListener('click', () => {
            const isOpen = panel.classList.toggle('open');
            btn.classList.toggle('active', isOpen);
            btn.setAttribute('aria-expanded', String(isOpen));
        });
    });

    const voiceModeEl = document.getElementById('setting-voice-mode');
    if (voiceModeEl) {
        voiceModeEl.value = app.settings.voiceMode || 'auto';
        updateVoiceModeUI();
        voiceModeEl.addEventListener('change', (e) => {
            app.settings.voiceMode = e.target.value;
            updateVoiceModeUI();
            saveData();
        });
    }

    document.getElementById('setting-voice').addEventListener('change', (e) => {
        app.settings.voiceURI = e.target.value;
        saveData();
    });

    // Autoplay toggle
    const autoplayEl = document.getElementById('setting-autoplay');
    if (autoplayEl) {
        autoplayEl.checked = Boolean(app.settings.autoplay);
        autoplayEl.addEventListener('change', (e) => {
            app.settings.autoplay = e.target.checked;
            saveData();
        });
    }
    const blockSuggestionsEl = document.getElementById('setting-block-suggestions');
    if (blockSuggestionsEl) {
        blockSuggestionsEl.checked = Boolean(app.settings.blockSuggestions);
        blockSuggestionsEl.addEventListener('change', (e) => {
            app.settings.blockSuggestions = e.target.checked;
            applySuggestionSettingToInput(document.getElementById('p-input'));
            saveData();
        });
    }
    // Strictness select
    const strictEl = document.getElementById('setting-strictness');
    if (strictEl) {
        strictEl.value = app.settings.strictness || 'strict';
        strictEl.addEventListener('change', (e) => {
            app.settings.strictness = e.target.value;
            saveData();
        });
    }
    // Timer start select
    const timerEl = document.getElementById('setting-timerStart');
    if (timerEl) {
        timerEl.value = app.settings.timerStart || 'audio';
        timerEl.addEventListener('change', (e) => {
            app.settings.timerStart = e.target.value;
            saveData();
        });
    }
    const dictationRepeatsEl = document.getElementById('setting-dictation-repeats');
    if (dictationRepeatsEl) {
        dictationRepeatsEl.value = Number.isFinite(app.settings.dictationRepeats)
            ? String(app.settings.dictationRepeats)
            : '1';
        dictationRepeatsEl.addEventListener('change', (e) => {
            app.settings.dictationRepeats = Number(e.target.value);
            saveData();
        });
    }
}

function exportData() {
    const str = JSON.stringify(app);
    const blob = new Blob([str], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "spellmaster_backup.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

document.getElementById('import-file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        let decks = [];
        try {
            const data = JSON.parse(e.target.result);
            if (data.decks) {
                app = data;
                saveData();
                location.reload();
                return;
            }
            decks = normalizeImportedDecks(data);
            if (!decks.length) {
                alert("Invalid file");
                return;
            }
        } catch(err) { alert("Invalid file"); }
        if (!decks.length) return;
        app.decks.push(...decks);
        saveData();
        renderDeckList();
    };
    reader.readAsText(file);
});

document.getElementById('import-deck-file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = JSON.parse(event.target.result);
            const decks = normalizeImportedDecks(data);
            if (!decks.length) {
                alert("Invalid pack file");
                return;
            }
            app.decks.push(...decks);
            saveData();
            renderDeckList();
            closeDeckModal();
        } catch (err) {
            alert("Invalid pack file");
        }
    };
    reader.readAsText(file);
    e.target.value = '';
});

function resetApp() {
    if(confirm("Delete all data? This cannot be undone.")) {
        localStorage.removeItem('spellmaster_data_v2');
        location.reload();
    }
}

// --- BOOTSTRAP ---
initAudio();
loadData();
initLanguageFilter();
initCardInputListeners();
document.addEventListener('keydown', handlePracticeKeydown);

</script>
</body>
</html>
