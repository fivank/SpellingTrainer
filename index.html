<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SpellMaster</title>
<style>
    /* --- VARIABLES & RESET --- */
    :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --bg-body: #f3f4f6;
        --bg-card: #ffffff;
        --text-main: #1f2937;
        --text-sub: #6b7280;
        --success: #10b981;
        --error: #ef4444;
        --nav-height: 72px;
        --radius: 16px;
        --radius-sm: 12px;
        --space-1: 8px;
        --space-2: 16px;
        --space-3: 24px;
        --space-4: 32px;
        --space-5: 40px;
        --font-h1: 1.75rem;
        --font-h2: 1.35rem;
        --font-body: 1rem;
        --font-small: 0.85rem;
        /* additional neutral colour used for toggles */
        --neutral-200: #e5e7eb;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg-body);
        color: var(--text-main);
        font-size: var(--font-body);
        line-height: 1.6;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    h1, h2, h3 {
        margin: 0 0 var(--space-2);
        line-height: 1.2;
    }
    h1 { font-size: var(--font-h1); }
    h2 { font-size: var(--font-h2); }
    h3 { font-size: 1.05rem; }
    p { margin: 0 0 var(--space-2); }
    small, .text-small { font-size: var(--font-small); }

    /* --- LAYOUT --- */
    header {
        padding: var(--space-2);
        background: var(--bg-card);
        text-align: center;
        font-weight: 800;
        font-size: var(--font-h2);
        color: var(--primary);
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        z-index: 10;
        flex-shrink: 0;
    }

    main {
        flex: 1;
        overflow-y: auto;
        padding: var(--space-3);
        padding-bottom: calc(var(--nav-height) + 120px + env(safe-area-inset-bottom));
        max-width: 600px;
        width: 100%;
        margin: 0 auto;
        scroll-padding-bottom: calc(var(--nav-height) + 120px + env(safe-area-inset-bottom));
    }

    .view { display: none; min-height: 100%; }
    .view.active { display: block; animation: fadeIn 0.3s ease; }

    /* --- NAVIGATION --- */
    nav {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: var(--nav-height);
        background: var(--bg-card);
        border-top: 1px solid rgba(148, 163, 184, 0.2);
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 20;
        padding-bottom: env(safe-area-inset-bottom);
    }

    nav button {
        background: none;
        border: none;
        color: var(--text-sub);
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: var(--font-small);
        width: 100%;
        height: 100%;
        justify-content: center;
        cursor: pointer;
        gap: 2px;
    }

    nav button svg { width: 24px; height: 24px; margin-bottom: 4px; fill: currentColor; overflow: visible; }
    nav button.active { color: var(--primary); }

    /* --- COMPONENTS --- */
    .card {
        background: var(--bg-card);
        border-radius: var(--radius);
        padding: var(--space-3);
        box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
        margin-bottom: var(--space-2);
        transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 24px -16px rgba(15, 23, 42, 0.25);
    }

    .progress-metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: var(--space-2);
    }

    .progress-metric {
        background: #f8fafc;
        border-radius: var(--radius-sm);
        padding: var(--space-2);
        border: 1px solid rgba(148, 163, 184, 0.3);
    }

    .progress-metric-label {
        color: var(--text-sub);
        font-size: var(--font-small);
        margin-bottom: 4px;
    }

    .progress-metric-value {
        font-size: 1.4rem;
        font-weight: 700;
    }

    .progress-trouble-list {
        display: flex;
        flex-direction: column;
        gap: var(--space-1);
        margin-bottom: var(--space-2);
    }

    .progress-trouble-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-2);
        padding: var(--space-1) 0;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .progress-trouble-item:last-child {
        border-bottom: none;
    }

    button {
        cursor: pointer;
        border: none;
        font-family: inherit;
        font-weight: 600;
        transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, color 0.12s ease, border-color 0.12s ease;
        outline: none;
    }
    button:active { transform: scale(0.98); }

    .btn-primary {
        background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        color: white;
        padding: var(--space-2);
        border-radius: var(--radius-sm);
        width: 100%;
        font-size: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-1);
        box-shadow: 0 12px 20px -12px rgba(99, 102, 241, 0.6);
    }
    .btn-primary:hover {
        box-shadow: 0 16px 24px -14px rgba(99, 102, 241, 0.7);
        transform: translateY(-1px);
    }
    .btn-primary:disabled {
        background: #d1d5db;
        color: #6b7280;
        box-shadow: none;
        cursor: not-allowed;
    }
    
    .btn-secondary {
        background: #ffffff;
        color: var(--primary-dark);
        border: 1px solid rgba(99, 102, 241, 0.35);
        padding: calc(var(--space-2) - 4px) var(--space-2);
        border-radius: var(--radius-sm);
        font-weight: 600;
        box-shadow: 0 8px 18px -14px rgba(15, 23, 42, 0.25);
    }
    .btn-secondary:hover {
        border-color: var(--primary);
        box-shadow: 0 12px 18px -14px rgba(15, 23, 42, 0.3);
    }
    
    .btn-icon {
        background: #f8fafc;
        padding: 8px;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(148, 163, 184, 0.35);
    }

    input, select {
        width: 100%;
        padding: var(--space-2);
        border: 2px solid #e5e7eb;
        border-radius: var(--radius-sm);
        font-size: 1rem;
        background: #f9fafb;
        margin-bottom: var(--space-2);
        -webkit-appearance: none; /* Fix for iOS input styles */
    }
    input:focus { border-color: var(--primary); outline: none; background: #fff; }

    /* --- PRACTICE SCREEN --- */
    .practice-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 80%;
    }

    .audio-stack {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--space-1);
        margin-bottom: var(--space-3);
    }
    .audio-trigger {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
        margin-bottom: 0;
        transition: transform 0.16s ease, box-shadow 0.16s ease;
        cursor: pointer;
        position: relative;
    }
    .audio-trigger:active { transform: scale(0.95); }
    .audio-trigger.playing { animation: pulse 1.5s infinite; }
    .audio-trigger svg { width: 50px; height: 50px; fill: white; }
    .audio-label {
        margin-top: var(--space-1);
        font-size: var(--font-small);
        font-weight: 700;
        color: var(--text-sub);
        letter-spacing: 0.02em;
    }

    .word-input {
        font-size: 2rem;
        text-align: center;
        border: none;
        border-bottom: 3px solid #e5e7eb;
        border-radius: 0;
        background: transparent;
        color: var(--primary);
        letter-spacing: 1px;
        font-weight: bold;
        margin-bottom: var(--space-2);
    }
    .word-input:focus { border-color: var(--primary); background: transparent; }
    
    .feedback-area { text-align: center; margin-bottom: 1rem; min-height: 24px; }
    .diff-display span { font-size: 1.2rem; font-weight: 600; }
    .diff-correct { color: var(--text-main); }
    .diff-wrong { color: var(--error); font-weight: 700; }

    .srs-controls { display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-1); width: 100%; margin-top: var(--space-4); }
    .srs-btn { padding: var(--space-2); border-radius: var(--radius-sm); font-size: 0.9rem; font-weight: 700; color: #333; }
    .srs-again { background: #fee2e2; color: #991b1b; }
    .srs-hard { background: #ffedd5; color: #9a3412; }
    .srs-good { background: #dcfce7; color: #166534; }
    .srs-easy { background: #dbeafe; color: #1e40af; }

    /* --- DECK LIST --- */
    .deck-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: var(--space-2);
        border-bottom: 1px solid #f3f4f6;
        margin-bottom: var(--space-2);
    }
    .deck-item:last-child { border: none; margin-bottom: 0; padding-bottom: 0; }
    .deck-info h3 { margin: 0 0 4px 0; font-size: 1.1rem; }
    .deck-info small { color: var(--text-sub); }
    
    /* --- MODAL --- */
    .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 100;
        display: flex; align-items: center; justify-content: center;
        opacity: 0; pointer-events: none; transition: opacity 0.18s ease;
        backdrop-filter: blur(2px);
    }
    .modal-overlay.open { opacity: 1; pointer-events: auto; }
    .modal {
        background: white; width: 90%; max-width: 400px;
        padding: var(--space-3); border-radius: var(--radius);
        transform: translateY(20px); transition: transform 0.18s ease;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }
    .modal-overlay.open .modal { transform: translateY(0); }
    .modal-toggle {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 1rem;
    }
    .modal-toggle button {
        padding: var(--space-2);
        border-radius: var(--radius-sm);
        border: 2px solid var(--primary);
        background: transparent;
        color: var(--primary);
        font-weight: 600;
    }
    .modal-toggle button.active {
        background: var(--primary);
        color: white;
    }
    .modal-panel.hidden {
        display: none;
    }

    .deck-actions {
        display: grid;
        gap: var(--space-1);
    }

    .deck-actions .btn-secondary,
    .deck-actions .btn-primary {
        width: 100%;
    }
    
    /* --- ANIMATIONS --- */
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(99, 102, 241, 0); } 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    .hidden { display: none !important; }
    .status-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; margin-top: 5px; }
    .status-ok { background: #dcfce7; color: #166534; }
    .status-err { background: #fee2e2; color: #991b1b; }

    /* Diff display styling for incorrect answers */
    .diff-display {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        justify-content: center;
        margin-top: 8px;
        margin-bottom: 8px;
        font-size: 1.1rem;
        line-height: 1.5;
        text-align: center;
    }
    .diff-highlight {
        color: var(--error);
        font-weight: 700;
    }
    .diff-line {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 999px;
        background: #f8fafc;
        border: 1px solid rgba(148, 163, 184, 0.3);
    }

    .practice-selection {
        display: flex;
        flex-direction: column;
        gap: var(--space-2);
    }
    .practice-deck-item {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        padding: var(--space-2);
        border: 1px solid #e5e7eb;
        border-radius: var(--radius-sm);
        background: #f9fafb;
        transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
    }
    .practice-deck-item input {
        margin: 0;
        width: auto;
        accent-color: var(--primary);
    }
    .practice-deck-item.selected {
        border-color: var(--primary);
        background: #eef2ff;
        box-shadow: 0 6px 12px rgba(99, 102, 241, 0.15);
    }
    .practice-deck-details {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
    }
    .practice-deck-name {
        font-weight: 600;
        font-size: 0.98rem;
    }
    .practice-deck-meta {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-1);
        font-size: 0.78rem;
        color: var(--text-sub);
    }
    .practice-filters {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-1);
        margin: var(--space-2) 0 var(--space-1);
    }
    .practice-filter-btn {
        padding: 8px 16px;
        border-radius: 999px;
        border: 1px solid #e5e7eb;
        background: #f3f4f6;
        color: var(--text-sub);
        font-size: 0.8rem;
        font-weight: 600;
    }
    .practice-filter-btn.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
    }
    .practice-header {
        display: flex;
        justify-content: flex-end;
        width: 100%;
        margin-bottom: 1rem;
    }
    .practice-end {
        color: var(--error);
        border-color: var(--error);
    }
    .practice-category-title {
        font-size: 0.95rem;
        color: var(--text-sub);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin: var(--space-1) 0 0;
    }
    .practice-category {
        display: flex;
        flex-direction: column;
        gap: var(--space-1);
    }
    .practice-empty {
        font-size: 0.9rem;
        color: var(--text-sub);
        margin: 0 0 8px;
    }
    .practice-progress {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: var(--space-1);
        margin: 0 auto var(--space-3);
    }
    .practice-progress-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.85rem;
        color: var(--text-sub);
        font-weight: 600;
    }
    .progress-track {
        width: 100%;
        height: 8px;
        background: #e5e7eb;
        border-radius: 999px;
        overflow: hidden;
    }
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--primary), var(--primary-dark));
        border-radius: 999px;
        transition: width 0.3s ease;
    }
    .practice-hint {
        margin-top: var(--space-1);
        font-size: 0.95rem;
        color: var(--text-sub);
        text-align: center;
    }
    .practice-hint strong {
        color: var(--primary-dark);
    }
    .feedback-positive {
        color: var(--success);
        font-weight: 700;
        font-size: 1.1rem;
    }
    .feedback-sub {
        margin-top: var(--space-1);
        font-size: 0.95rem;
        color: var(--text-sub);
    }
    .try-again-wrap {
        margin-top: 1rem;
        display: flex;
        justify-content: center;
    }
    .practice-options {
        display: grid;
        gap: var(--space-1);
        margin-bottom: var(--space-2);
    }
    .practice-option {
        padding: var(--space-2);
        border-radius: var(--radius-sm);
        border: 1px solid #e5e7eb;
        background: #f9fafb;
        display: flex;
        flex-direction: column;
        gap: 4px;
        cursor: pointer;
        transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
    }
    .practice-option.selected {
        border-color: var(--primary);
        background: #eef2ff;
        box-shadow: 0 6px 12px rgba(99, 102, 241, 0.12);
    }
    .practice-option.disabled {
        opacity: 0.55;
        cursor: not-allowed;
    }
    .practice-option-title {
        font-weight: 700;
        font-size: 0.95rem;
    }
    .practice-option-desc {
        font-size: 0.85rem;
        color: var(--text-sub);
    }

    /* Toggle switch styling (borrowed from improved version) */
    .toggle {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
    }
    .toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--neutral-200);
        transition: 0.4s;
        border-radius: 24px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
    }
    .toggle input:checked + .slider {
        background-color: var(--primary);
    }
    .toggle input:checked + .slider:before {
        transform: translateX(26px);
    }
</style>
</head>
<body>

<header>SpellMaster</header>

<main>
    <!-- PRACTICE SCREEN -->
    <div id="view-practice" class="view active">
        <div class="practice-wrapper" id="practice-container">
            <!-- Dynamic Content -->
            <div style="text-align: center; color: var(--text-sub);">
                <h2>Today's Practice</h2>
                <p>Press Start to begin.</p>
                <br>
                <button class="btn-primary" onclick="startTodayPractice()">Start today’s practice</button>
            </div>
        </div>
    </div>

    <!-- WORDS / DECKS SCREEN -->
    <div id="view-words" class="view">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h2>My Decks</h2>
            <button class="btn-secondary" onclick="openDeckModal()">+ New</button>
        </div>
        <div class="card" id="deck-list-container">
            <div id="deck-list"></div>
        </div>
    </div>

    <!-- SETTINGS SCREEN -->
    <div id="view-settings" class="view">
        <h2>Settings</h2>
        
        <!-- Learning Settings -->
        <div class="card">
            <h3>Learning</h3>
            <div>
                <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span>Autoplay audio</span>
                    <label class="toggle"><input type="checkbox" id="setting-autoplay"><span class="slider"></span></label>
                </label>
                <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span>Block keyboard suggestions</span>
                    <label class="toggle"><input type="checkbox" id="setting-block-suggestions"><span class="slider"></span></label>
                </label>
                <label style="display:block; margin-bottom:8px;">
                    Answer strictness
                    <select id="setting-strictness" style="width:100%; margin-top:4px;">
                        <option value="strict">Strict</option>
                        <option value="lenient">Lenient</option>
                    </select>
                </label>
                <label style="display:block;">
                    Timer start
                    <select id="setting-timerStart" style="width:100%; margin-top:4px;">
                        <option value="show">On show</option>
                        <option value="audio">On audio</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="card">
            <h3>Audio Diagnostics</h3>
            <p style="font-size:0.9rem; color: var(--text-sub);">If audio isn't working, check here.</p>
            <div id="audio-status" class="status-badge status-err">Checking...</div>
            <div style="margin-top:var(--space-1);">
                <label>Voice mode</label>
                <select id="setting-voice-mode">
                    <option value="auto">Auto (match deck language)</option>
                    <option value="fixed">Fixed (use selected voice)</option>
                </select>
                <p style="font-size:0.8rem; color: var(--text-sub); margin: var(--space-1) 0 var(--space-2);">
                    Auto mode chooses a voice that matches the deck language (e.g., Spanish decks use Spanish voices).
                </p>
            </div>
            <div>
                <label>System Voice</label>
                <select id="setting-voice"><option>Loading voices...</option></select>
            </div>
            <div>
                <label>Speed: <span id="speed-val">1.0</span>x</label>
                <input type="range" id="setting-speed" min="0.5" max="1.5" step="0.1" value="1">
            </div>
            <button class="btn-secondary" onclick="testAudio()">Test Audio</button>
        </div>
        
        <div class="card">
            <h3>Data Management</h3>
            <button class="btn-secondary" onclick="exportData()" style="width:100%; margin-bottom:var(--space-1);">Export Backup</button>
            <button class="btn-secondary" onclick="document.getElementById('import-file').click()" style="width:100%; margin-bottom:var(--space-1);">Import Backup</button>
            <input type="file" id="import-file" class="hidden" accept=".json">
            <button class="btn-secondary" style="color: var(--error); border-color: var(--error); width:100%;" onclick="resetApp()">Reset All Data</button>
        </div>
    </div>

    <!-- PROGRESS SCREEN -->
    <div id="view-progress" class="view">
        <h2>What’s next</h2>
        <p class="text-small" style="color:var(--text-sub);">Focus on the next step that grows your mastery.</p>
        <div class="card" id="progress-overview" style="margin-bottom:1rem;"></div>
        <div class="card" id="progress-details"></div>
    </div>

    <!-- DECK PROGRESS SCREEN -->
    <div id="view-deck-progress" class="view">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:1rem;">
            <button class="btn-secondary" onclick="navTo('words')">← Back</button>
            <h2 style="margin:0;" id="deck-progress-title">Deck Progress</h2>
            <button class="btn-secondary" id="deck-reset-stats" onclick="resetDeckStats()">Reset Stats</button>
        </div>
        <div class="card" id="deck-progress-overview" style="margin-bottom:1rem;"></div>
        <div class="card" id="deck-progress-details"></div>
    </div>
</main>

<nav>
    <button onclick="navTo('practice')" id="nav-practice" class="active">
        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
        Today
    </button>
    <button onclick="navTo('words')" id="nav-words">
        <svg viewBox="0 0 24 24"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z"/></svg>
        Decks
    </button>
    <button onclick="navTo('progress')" id="nav-progress">
        <svg viewBox="0 0 24 24"><path d="M3 17h4V9H3v8zm6 0h4V5H9v12zm6 0h4V13h-4v4z"/></svg>
        Progress
    </button>

    <button onclick="navTo('settings')" id="nav-settings">
        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L5.09 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.58 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
        Settings
    </button>
</nav>

<!-- ADD DECK MODAL -->
<div id="deck-modal" class="modal-overlay">
    <div class="modal">
        <h3>New Deck</h3>
        <div class="modal-toggle">
            <button type="button" id="deck-toggle-create" class="active" onclick="showDeckPanel('create')">Create</button>
            <button type="button" id="deck-toggle-import" onclick="showDeckPanel('import')">Import</button>
        </div>
        <div id="deck-panel-create" class="modal-panel">
            <label>Deck Name</label>
            <input type="text" id="new-deck-name" placeholder="e.g. Spanish Basics">
            <label>Language</label>
            <select id="new-deck-lang">
                <option value="en-US">English (US)</option>
                <option value="en-GB">English (UK)</option>
                <option value="es-ES">Spanish</option>
                <option value="fr-FR">French</option>
                <option value="de-DE">German</option>
                <option value="it-IT">Italian</option>
            </select>
            <label for="new-deck-text">Dictation Text (optional)</label>
            <textarea id="new-deck-text" rows="5" placeholder="Paste the full dictation passage." style="width:100%; padding:var(--space-2); border:2px solid #e5e7eb; border-radius:var(--radius-sm); font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical;"></textarea>
            <div style="display:flex; gap:var(--space-1); margin-top:var(--space-2);">
                <button class="btn-secondary" onclick="closeDeckModal()" style="flex:1">Cancel</button>
                <button class="btn-primary" onclick="saveDeck()" style="flex:1">Create</button>
            </div>
        </div>
        <div id="deck-panel-import" class="modal-panel hidden">
            <p style="font-size:0.95rem; color:var(--text-sub); margin-top:0;">
                Import a compatible deck JSON file to add it to your collection.
            </p>
            <button class="btn-secondary" onclick="triggerDeckImport()" style="width:100%; margin-bottom:var(--space-1);">Choose Deck File</button>
            <button class="btn-secondary" onclick="focusDeckPaste()" style="width:100%; margin-bottom:var(--space-1);">Paste Deck as JSON</button>
            <input type="file" id="import-deck-file" class="hidden" accept=".json,application/json">
            <div style="margin-bottom:var(--space-1);">
                <label for="import-deck-json" style="display:block; font-size:0.85rem; color:var(--text-sub); margin-bottom:6px;">
                    Paste deck as JSON
                </label>
                <textarea id="import-deck-json" rows="6" placeholder='{"name":"My Deck","lang":"en-US","text":"First sentence. Second sentence.","cards":[{"word":"example","sentence":"First sentence."}]}' style="width:100%; padding:var(--space-2); border:2px solid #e5e7eb; border-radius:var(--radius-sm); font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical;"></textarea>
            </div>
            <button class="btn-secondary" onclick="importDeckFromPaste()" style="width:100%; margin-bottom:var(--space-1);">Import Pasted Deck</button>
            <div style="display:flex; gap:var(--space-1);">
                <button class="btn-secondary" onclick="closeDeckModal()" style="flex:1">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- MANAGE CARDS MODAL -->
<div id="cards-modal" class="modal-overlay">
    <div class="modal" style="max-height: 85vh; display:flex; flex-direction:column;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3>Manage Cards</h3>
            <button class="btn-icon" onclick="closeCardsModal()">✕</button>
        </div>
        <div style="margin-bottom:1rem;">
            <input type="text" id="new-card-word" placeholder="Word to spell" style="margin-bottom:8px;">
            <input type="text" id="new-card-sentence" placeholder="Sentence (optional)" style="margin-bottom:8px;">
            <!-- Optional audio URL input to support custom pronunciation files -->
            <input type="text" id="new-card-audio" placeholder="Audio URL (optional)" style="margin-bottom:8px;">
            <button class="btn-primary" onclick="addCardToDeck()">Add Card</button>
        </div>
        <div style="flex:1; overflow-y:auto; border-top:1px solid #eee; padding-top:var(--space-1);" id="cards-list-content">
            <!-- Cards list -->
        </div>
    </div>
</div>

<!-- DECK ACTIONS MODAL -->
<div id="deck-actions-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3 id="deck-actions-title">Deck Actions</h3>
            <button class="btn-icon" onclick="closeDeckActionsModal()">✕</button>
        </div>
        <div class="deck-actions">
            <button class="btn-primary" onclick="openDeckStats()">Stats</button>
            <button class="btn-secondary" onclick="openDeckEditor()">Edit Words</button>
            <button class="btn-secondary" onclick="openDeckMetaEditor()">Edit Name/Language</button>
            <button class="btn-secondary" onclick="exportDeck()">Export Deck</button>
            <button class="btn-secondary" style="color: var(--error); border-color: var(--error);" onclick="deleteDeck()">Delete Deck</button>
        </div>
    </div>
</div>

<!-- PRACTICE OPTIONS MODAL -->
<div id="practice-options-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3 id="practice-options-title">Practice Options</h3>
            <button class="btn-icon" onclick="closePracticeOptionsModal()">✕</button>
        </div>
        <div id="practice-options-list" class="practice-options"></div>
        <p id="practice-options-note" class="text-small" style="color: var(--text-sub); margin-top:0;"></p>
        <button class="btn-primary" id="practice-options-start" onclick="startPracticeFromOptions()" disabled>Start practice</button>
    </div>
</div>

<!-- EDIT DECK META MODAL -->
<div id="deck-meta-modal" class="modal-overlay">
    <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
            <h3>Edit Name/Language</h3>
            <button class="btn-icon" onclick="closeDeckMetaModal()">✕</button>
        </div>
        <label for="edit-deck-name">Deck Name</label>
        <input type="text" id="edit-deck-name" placeholder="Deck name">
        <label for="edit-deck-lang">Language</label>
        <select id="edit-deck-lang">
            <option value="en-US">English (US)</option>
            <option value="en-GB">English (UK)</option>
            <option value="es-ES">Spanish</option>
            <option value="fr-FR">French</option>
            <option value="de-DE">German</option>
            <option value="it-IT">Italian</option>
        </select>
        <label for="edit-deck-text">Dictation Text (optional)</label>
        <textarea id="edit-deck-text" rows="5" placeholder="Enter the full dictation passage." style="width:100%; padding:var(--space-2); border:2px solid #e5e7eb; border-radius:var(--radius-sm); font-size:0.95rem; font-family:inherit; background:#f9fafb; resize:vertical;"></textarea>
        <div style="display:flex; gap:var(--space-1);">
            <button class="btn-secondary" onclick="closeDeckMetaModal()" style="flex:1">Cancel</button>
            <button class="btn-primary" onclick="saveDeckMeta()" style="flex:1">Save</button>
        </div>
    </div>
</div>

<script>
/**
 * APP DATA
 */
let app = {
    decks: [],
    settings: {
        voiceURI: null,
        voiceMode: 'auto',
        speed: 1.0,
        /* whether to automatically play audio when a card appears */
        autoplay: true,
        /* whether to block keyboard suggestions on the practice input */
        blockSuggestions: false,
        /* answer strictness: 'strict' = case-sensitive; 'lenient' = case-insensitive */
        strictness: 'strict',
        /* when to start timing user response: 'show' or 'audio' */
        timerStart: 'audio'
    }
};

let currentSession = {
    deck: null,
    decks: [],
    queue: [],
    currentCard: null,
    currentEntry: null,
    isAnswered: false,
    isActive: false,
    lastAnswerCorrect: null,
    selectedDeckIds: [],
    practiceFilter: 'all',
    startTime: null,
    sessionStartTime: null,
    totalCount: 0,
    completedCount: 0,
    correctAttempts: 0,
    totalAttempts: 0,
    troubleEntries: []
};

let lastSessionSummary = null;
let progressTroubleEntries = [];
let activePracticeDeckId = null;
let selectedPracticeMode = null;

// --- AUDIO ENGINE (ROBUST VERSION) ---
let availableVoices = [];

function initAudio() {
    const statusEl = document.getElementById('audio-status');
    const select = document.getElementById('setting-voice');

    if (!('speechSynthesis' in window)) {
        statusEl.className = 'status-badge status-err';
        statusEl.textContent = 'Not Supported in this Browser';
        select.innerHTML = '<option>Not available</option>';
        return;
    }

    // Attempt to load voices
    const loadVoices = () => {
        const freshVoices = window.speechSynthesis.getVoices();
        if (freshVoices.length > 0) {
            availableVoices = freshVoices;
            statusEl.className = 'status-badge status-ok';
            statusEl.textContent = 'Engine Ready';
            populateVoiceSelect();
            return true;
        }
        // Keep waiting or show warning
        statusEl.className = 'status-badge status-err';
        statusEl.textContent = 'Voices Empty (Try Chrome/Safari)';
        return false;
    };

    // Modern browsers load async
    window.speechSynthesis.onvoiceschanged = loadVoices;
    
    // Initial attempt
    loadVoices();
    
    // Some browsers need a kick
    setTimeout(loadVoices, 500);

    // Keep retrying briefly for browsers that populate voices late.
    let retries = 0;
    const retryTimer = setInterval(() => {
        retries += 1;
        const loaded = loadVoices();
        if (loaded || retries >= 10) {
            clearInterval(retryTimer);
        }
    }, 500);
}

function normalizeLangCode(lang) {
    return lang ? String(lang).replace('_', '-').toLowerCase() : '';
}

function getBestVoiceForLang(lang) {
    if (!lang) return null;
    const normalized = normalizeLangCode(lang);
    const baseLang = normalized.split('-')[0];
    const exactMatches = availableVoices.filter(v => normalizeLangCode(v.lang) === normalized);
    const baseMatches = availableVoices.filter(v => {
        const voiceLang = normalizeLangCode(v.lang);
        return voiceLang && voiceLang.startsWith(baseLang);
    });
    const candidates = exactMatches.length ? exactMatches : baseMatches;
    if (!candidates.length) return null;
    return candidates.find(v => v.default) || candidates.find(v => v.localService) || candidates[0];
}

function updateVoiceModeUI() {
    const modeEl = document.getElementById('setting-voice-mode');
    const voiceSelect = document.getElementById('setting-voice');
    if (!modeEl || !voiceSelect) return;
    voiceSelect.disabled = modeEl.value === 'auto';
}

function populateVoiceSelect() {
    const select = document.getElementById('setting-voice');
    select.innerHTML = '';
    
    // Group by language
    availableVoices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI;
        opt.textContent = `${v.name} (${v.lang})`;
        select.appendChild(opt);
    });

    // Restore saved choice
    if (app.settings.voiceURI) {
        // Verify it still exists
        const exists = availableVoices.find(v => v.voiceURI === app.settings.voiceURI);
        if (exists) select.value = app.settings.voiceURI;
    }
    updateVoiceModeUI();
}

function speak(text, lang) {
    if (!('speechSynthesis' in window)) {
        alert("Your browser does not support Audio. Please try Chrome or Safari.");
        return;
    }

    if (availableVoices.length === 0) {
        const freshVoices = window.speechSynthesis.getVoices();
        if (freshVoices.length > 0) {
            availableVoices = freshVoices;
            populateVoiceSelect();
        }
    }
    
    window.speechSynthesis.cancel(); // Stop current

    const u = new SpeechSynthesisUtterance(text);
    u.rate = parseFloat(app.settings.speed) || 1.0;
    
    // --- VOICE SELECTION LOGIC ---
    let voice = null;
    
    // 1. Try User Preference when fixed mode is enabled
    if (app.settings.voiceMode === 'fixed' && app.settings.voiceURI) {
        voice = availableVoices.find(v => v.voiceURI === app.settings.voiceURI);
    }
    
    // 2. If no preference or invalid, find best match for Deck Language
    if (!voice && lang) {
        voice = getBestVoiceForLang(lang);
    }

    if (voice) {
        u.voice = voice;
        u.lang = voice.lang; // Ensure lang matches voice
    } else {
        // 3. Last Resort: Let browser decide based on lang code
        u.lang = lang || 'en-US';
    }

    // Visual Feedback
    const btn = document.querySelector('.audio-trigger');
    if(btn) btn.classList.add('playing');

    u.onend = () => { if(btn) btn.classList.remove('playing'); };
    u.onerror = (e) => { 
        if(btn) btn.classList.remove('playing');
        console.warn("Audio Error:", e);
    };

    window.speechSynthesis.speak(u);
}

function testAudio() {
    const modeEl = document.getElementById('setting-voice-mode');
    const s = document.getElementById('setting-voice');
    let lang = 'en-US';
    if (modeEl && modeEl.value === 'fixed') {
        const v = availableVoices.find(v => v.voiceURI === s.value);
        lang = v ? v.lang : lang;
    } else {
        lang = app.decks.length > 0 ? app.decks[0].lang : lang;
    }
    speak("This is a test of the audio system.", lang);
}

// --- PERSISTENCE ---
function loadData() {
    const raw = localStorage.getItem('spellmaster_data_v2');
    if (raw) {
        try {
            const data = JSON.parse(raw);
            app.decks = data.decks || [];
            app.settings = { ...app.settings, ...data.settings };
        } catch(e) { console.error("Data load error", e); }
    }
    // Ensure all cards have expected properties (migration for newer versions)
    app.decks.forEach(deck => {
        if (deck.uncompleted === undefined) deck.uncompleted = false;
        if (deck.lastPracticed === undefined) deck.lastPracticed = null;
        if (deck.text === undefined) deck.text = '';
        if (deck.dictationStatsReady === undefined) deck.dictationStatsReady = false;
        deck.cards.forEach(card => {
            if (card.audioUrl === undefined) card.audioUrl = '';
            if (card.correctCount === undefined) card.correctCount = 0;
            if (card.incorrectCount === undefined) card.incorrectCount = 0;
            if (card.avgTime === undefined) card.avgTime = 0;
            if (card.interval === undefined) card.interval = 0;
            if (card.ease === undefined) card.ease = 2.5;
            if (card.due === undefined) card.due = 0;
        });
        if (!deck.dictationStatsReady) {
            deck.dictationStatsReady = deck.cards.some(card => (card.correctCount || 0) + (card.incorrectCount || 0) > 0);
        }
    });
    renderDeckList();
    initSettingsListeners();
    renderPracticeHome();
}

function saveData() {
    localStorage.setItem('spellmaster_data_v2', JSON.stringify(app));
}

// --- NAV ---
function navTo(screen) {
    document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
    document.getElementById('view-' + screen).classList.add('active');
    
    document.querySelectorAll('nav button').forEach(el => el.classList.remove('active'));
    const navBtn = document.getElementById('nav-' + screen);
    if (navBtn) navBtn.classList.add('active');
    
    if (screen === 'words') {
        renderDeckList();
    } else if (screen === 'progress') {
        renderProgress();
    } else if (screen === 'practice') {
        if (!currentSession.isActive) {
            renderPracticeHome();
        }
    }
}

// --- PRACTICE ---
function startPractice(deckIds) {
    const selectedDecks = app.decks.filter(d => deckIds.includes(d.id));
    if (!selectedDecks.length) return;
    
    // Sort by due date
    const now = Date.now();
    let entries = selectedDecks.flatMap(deck => {
        if (isDictationDeck(deck) && !deckHasDictationStats(deck)) {
            return buildDictationTextEntry(deck);
        }
        if (isDictationDeck(deck)) {
            return buildDictationEntries(deck);
        }
        return buildWordEntries(deck, now, true);
    }).sort((a,b) => {
        if (a.mode === 'dictation' || b.mode === 'dictation') return 0;
        if (a.mode === 'dictation-text' || b.mode === 'dictation-text') return 0;
        return a.card.due - b.card.due;
    });
    
    // If no due cards, practice all
    if (entries.length === 0) {
        entries = selectedDecks.flatMap(deck => {
            if (isDictationDeck(deck) && !deckHasDictationStats(deck)) {
                return buildDictationTextEntry(deck);
            }
            if (isDictationDeck(deck)) {
                return buildDictationEntries(deck);
            }
            return buildWordEntries(deck, now, false);
        });
    }

    if (entries.length === 0) {
        alert("No cards available in the selected decks.");
        return;
    }

    startPracticeEntries(entries, selectedDecks);
}

function startPracticeEntries(entries, selectedDecks = []) {
    currentSession.queue = entries.slice();
    currentSession.deck = null;
    currentSession.decks = selectedDecks;
    currentSession.isActive = true;
    currentSession.sessionStartTime = Date.now();
    currentSession.totalCount = entries.length;
    currentSession.completedCount = 0;
    currentSession.correctAttempts = 0;
    currentSession.totalAttempts = 0;
    currentSession.troubleEntries = [];
    lastSessionSummary = null;
    navTo('practice');
    nextCard();
}

function startPracticeFromSelection() {
    const selected = currentSession.selectedDeckIds || [];
    if (!selected.length) {
        alert("Select at least one deck to practice.");
        return;
    }
    startPractice(selected);
}

function startTodayPractice() {
    if (!app.decks.length) return;
    const deckIds = app.decks.map(deck => deck.id);
    startPractice(deckIds);
}

function startTroublePractice() {
    if (!lastSessionSummary || !Array.isArray(lastSessionSummary.troubleEntries)) {
        return;
    }
    const uniqueMap = new Map();
    lastSessionSummary.troubleEntries.forEach(entry => {
        const key = `${entry.deck.id}-${entry.card.word}`;
        if (!uniqueMap.has(key)) {
            uniqueMap.set(key, entry);
        }
    });
    const entries = Array.from(uniqueMap.values());
    if (!entries.length) return;
    const selectedDecks = Array.from(new Set(entries.map(entry => entry.deck)));
    startPracticeEntries(entries, selectedDecks);
}

function startProgressTroublePractice() {
    if (!progressTroubleEntries.length) return;
    const uniqueMap = new Map();
    progressTroubleEntries.forEach(entry => {
        const key = `${entry.deck.id}-${entry.card.word}`;
        if (!uniqueMap.has(key)) {
            uniqueMap.set(key, entry);
        }
    });
    const entries = Array.from(uniqueMap.values());
    if (!entries.length) return;
    const selectedDecks = Array.from(new Set(entries.map(entry => entry.deck)));
    startPracticeEntries(entries, selectedDecks);
}

function openPasteList() {
    openDeckModal();
    showDeckPanel('import');
    setTimeout(() => focusDeckPaste(), 0);
}

function triggerBackupRestore() {
    const input = document.getElementById('import-file');
    if (input) {
        input.click();
    }
}

function addSampleDeck() {
    app.decks.push(createSampleDeck());
    saveData();
    renderDeckList();
    renderPracticeHome();
}

function endPracticeSession() {
    if (!currentSession.isActive) return;
    if (!confirm("End this practice session early?")) return;
    const remainingDeckIds = new Set(currentSession.queue.map(entry => entry.deck.id));
    currentSession.decks.forEach(deck => {
        deck.uncompleted = remainingDeckIds.has(deck.id);
    });
    saveData();
    currentSession.isActive = false;
    currentSession.queue = [];
    currentSession.currentCard = null;
    currentSession.currentEntry = null;
    currentSession.deck = null;
    currentSession.decks = [];
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    currentSession.startTime = null;
    currentSession.sessionStartTime = null;
    currentSession.totalCount = 0;
    currentSession.completedCount = 0;
    currentSession.correctAttempts = 0;
    currentSession.totalAttempts = 0;
    currentSession.troubleEntries = [];
    if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
    }
    renderPracticeHome();
}

function renderPracticeHome() {
    const container = document.getElementById('practice-container');
    if (!container) return;

    if (app.decks.length === 0) {
        container.innerHTML = `
            <div class="card" style="text-align:center;">
                <h2 style="margin-top:0;">Welcome to SpellMaster</h2>
                <p style="color: var(--text-sub); margin-bottom:1.5rem;">
                    Choose a starting point to set up your first deck.
                </p>
                <div style="display:grid; gap:var(--space-1);">
                    <button class="btn-primary" onclick="addSampleDeck()">Try sample</button>
                    <button class="btn-secondary" onclick="openPasteList()">Paste list</button>
                    <button class="btn-secondary" onclick="triggerBackupRestore()">Restore backup</button>
                </div>
            </div>
        `;
        return;
    }
    const now = Date.now();
    const { dueCount, newCount, troubleCount, totalCards } = getTodayCounts(now);
    const isStartDisabled = totalCards === 0;
    const startCopy = isStartDisabled ? 'Add words to start practicing' : 'Press Start to begin today’s practice.';

    container.innerHTML = `
        <div class="card" style="text-align:center;">
            <h2 style="margin-top:0;">Today</h2>
            <p style="color: var(--text-sub); margin-bottom:1.5rem;">${startCopy}</p>
            <button class="btn-primary" ${isStartDisabled ? 'disabled' : ''} onclick="startTodayPractice()">Start today’s practice</button>
            <div style="margin-top:1.5rem; display:grid; gap:6px; text-align:left;">
                <div><strong>Due now:</strong> ${dueCount}</div>
                <div><strong>New:</strong> ${newCount}</div>
                <div><strong>Trouble:</strong> ${troubleCount}</div>
            </div>
            <div style="margin-top:var(--space-3); display:grid; gap:var(--space-1);">
                <button class="btn-secondary" onclick="navTo('words')">Go to Decks</button>
            </div>
        </div>
    `;
}

function formatDuration(ms) {
    if (!ms || ms < 0) return '0:00';
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function getHintMarkup(word) {
    if (!word) return '';
    const safeWord = String(word).trim();
    const firstLetter = safeWord.charAt(0).toUpperCase();
    const lengthHint = safeWord.split('').map(() => '_').join(' ');
    return `<div class="practice-hint">Hint: starts with <strong>${firstLetter}</strong> • ${lengthHint}</div>`;
}

function nextCard() {
    if (currentSession.queue.length === 0) {
        const totalAttempts = currentSession.totalAttempts || 0;
        const correctAttempts = currentSession.correctAttempts || 0;
        const accuracy = totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0;
        const durationMs = currentSession.sessionStartTime ? Date.now() - currentSession.sessionStartTime : 0;
        const troubleEntries = currentSession.troubleEntries || [];
        lastSessionSummary = {
            accuracy,
            durationMs,
            troubleEntries
        };
        const troubleButton = troubleEntries.length > 0
            ? `<button class="btn-secondary" onclick="startTroublePractice()">Practice trouble words</button>`
            : '';
        document.getElementById('practice-container').innerHTML = `
            <div class="card" style="text-align:center">
                <h2 style="margin-top:0;">Completed</h2>
                <p style="color:var(--text-sub); margin-bottom:1.5rem;">You finished this session.</p>
                <div style="display:grid; gap:8px; text-align:left; margin-bottom:1.5rem;">
                    <div><strong>Accuracy:</strong> ${accuracy}%</div>
                    <div><strong>Time:</strong> ${formatDuration(durationMs)}</div>
                </div>
                <div style="display:grid; gap:var(--space-1);">
                    <button class="btn-primary" onclick="navTo('practice'); renderPracticeHome();">Practice More</button>
                    ${troubleButton}
                </div>
            </div>`;
        currentSession.decks.forEach(deck => {
            deck.uncompleted = false;
        });
        saveData();
        currentSession.isActive = false;
        currentSession.currentCard = null;
        currentSession.currentEntry = null;
        currentSession.deck = null;
        currentSession.sessionStartTime = null;
        currentSession.totalCount = 0;
        currentSession.completedCount = 0;
        currentSession.correctAttempts = 0;
        currentSession.totalAttempts = 0;
        currentSession.troubleEntries = [];
        return;
    }

    currentSession.currentEntry = currentSession.queue[0];
    currentSession.currentCard = currentSession.currentEntry.card || currentSession.currentEntry.primaryCard || null;
    currentSession.deck = currentSession.currentEntry.deck;
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    // Reset timer
    currentSession.startTime = null;
    
    const c = currentSession.currentCard;
    const entry = currentSession.currentEntry;
    const isDictation = entry.mode === 'dictation' || entry.mode === 'dictation-text';
    const isDictationText = entry.mode === 'dictation-text';
    const hasSentence = !isDictation && c && c.sentence && c.sentence.trim() !== "";
    
    // Hide target word in sentence
    let sentenceDisplay = "";
    if (hasSentence) {
        // Regex to match word case-insensitive
        const regex = new RegExp(`\\b${escapeRegExp(c.word)}\\b`, 'gi');
        sentenceDisplay = c.sentence.replace(regex, "____");
    }

    const totalCount = currentSession.totalCount || currentSession.queue.length;
    const currentIndex = Math.min(currentSession.completedCount + 1, totalCount);
    const progressPercent = totalCount ? Math.round((currentIndex / totalCount) * 100) : 0;
    const hintMarkup = !isDictation && c ? getHintMarkup(c.word) : '';
    const dictationNotice = isDictation ? `
        <p style="font-size:1rem; color:var(--text-sub); margin-bottom:var(--space-3); text-align:center;">
            ${isDictationText
                ? `Dictation text with ${entry.sentenceCount || 1} sentence${entry.sentenceCount === 1 ? '' : 's'}. Listen and type the full text.`
                : `Dictation sentence ${entry.sentenceIndex} of ${entry.sentenceCount}. Listen and type the full sentence.`}
        </p>
    ` : '';
    const html = `
        <div class="practice-header">
            <button class="btn-secondary practice-end" onclick="endPracticeSession()">End Session</button>
        </div>
        <div class="practice-progress">
            <div class="practice-progress-header">
                <span>Progress</span>
                <span>${currentIndex} / ${totalCount}</span>
            </div>
            <div class="progress-track" aria-hidden="true">
                <div class="progress-fill" style="width:${progressPercent}%"></div>
            </div>
        </div>
        <div class="audio-stack">
            <div class="audio-trigger" onclick="playCurrent()" role="button" aria-label="Play audio">
                <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            </div>
            <div class="audio-label">Play</div>
        </div>
        ${dictationNotice}
        ${hasSentence ? `<p style="font-size:1.2rem; color:var(--text-sub); margin-bottom:var(--space-4); text-align:center; padding:0 var(--space-3); line-height:1.5;">${sentenceDisplay}</p>` : ''}
        
        <div class="feedback-area" id="feedback"></div>
        
        <input type="text" id="p-input" class="word-input" placeholder="${isDictationText ? 'Type full text here' : (isDictation ? 'Type sentence here' : 'Type word here')}">
        ${hintMarkup}
        
        <button id="btn-check" class="btn-primary" style="margin-top:var(--space-2);" onclick="checkAnswer()">Check</button>
        
        <div id="srs-area" class="srs-controls hidden">
            <button class="srs-btn srs-again" onclick="rateCard(1)">Again</button>
            <button class="srs-btn srs-hard" onclick="rateCard(2)">Hard</button>
            <button class="srs-btn srs-good" onclick="rateCard(3)">Good</button>
            <button class="srs-btn srs-easy" onclick="rateCard(4)">Easy</button>
        </div>
    `;
    
    document.getElementById('practice-container').innerHTML = html;
    
    const input = document.getElementById('p-input');
    applySuggestionSettingToInput(input);
    input.focus();
    
    // Set timer if start on show
    if (app.settings.timerStart === 'show') {
        currentSession.startTime = Date.now();
    }
    // Autoplay audio if enabled
    if (app.settings.autoplay) {
        setTimeout(() => {
            playCurrent();
        }, 300);
    }

    // Keyboard support
    input.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
        if (currentSession.isAnswered) return;
        e.preventDefault();
        e.stopPropagation();
        checkAnswer();
    });
}

function applySuggestionSettingToInput(input) {
    if (!input) return;
    const shouldBlock = Boolean(app.settings.blockSuggestions);
    if (shouldBlock) {
        input.setAttribute('autocomplete', 'off');
        input.setAttribute('autocorrect', 'off');
        input.setAttribute('autocapitalize', 'off');
        input.setAttribute('spellcheck', 'false');
        input.setAttribute('aria-autocomplete', 'none');
    } else {
        input.removeAttribute('autocomplete');
        input.removeAttribute('autocorrect');
        input.removeAttribute('autocapitalize');
        input.removeAttribute('spellcheck');
        input.removeAttribute('aria-autocomplete');
    }
}

function playCurrent() {
    if (!currentSession.currentEntry) return;
    const card = currentSession.currentCard;
    const entry = currentSession.currentEntry;
    // Play custom audio if URL exists
    if (entry.mode !== 'dictation' && card && card.audioUrl) {
        try {
            const audio = new Audio(card.audioUrl);
            const btn = document.querySelector('.audio-trigger');
            if (btn) btn.classList.add('playing');
            audio.onplay = () => {
                if (app.settings.timerStart === 'audio') {
                    currentSession.startTime = Date.now();
                }
            };
            audio.onended = () => { if (btn) btn.classList.remove('playing'); };
            audio.onerror = () => {
                if (btn) btn.classList.remove('playing');
                // fallback to TTS if audio fails
                speakCard();
            };
            audio.play().catch((err) => {
                if (btn) btn.classList.remove('playing');
                speakCard();
            });
            return;
        } catch(e) {
            // fallback to speech synthesis
            speakCard();
            return;
        }
    }
    // Fallback to TTS
    speakCard();
    function speakCard() {
        // If timing starts on audio, start timer now
        if (app.settings.timerStart === 'audio') {
            currentSession.startTime = Date.now();
        }
        const lang = currentSession.deck ? currentSession.deck.lang : 'en-US';
        if (entry.mode === 'dictation-text') {
            speak(entry.text, lang);
            return;
        }
        if (entry.mode === 'dictation') {
            speak(entry.sentence, lang);
            return;
        }
        // If card has a sentence, speak word then sentence for context
        if (card.sentence && card.sentence.trim() !== '') {
            const phrase = `${card.word}. ${card.sentence}`;
            speak(phrase, lang);
        } else {
            speak(card.word, lang);
        }
    }
}

function checkAnswer() {
    const input = document.getElementById('p-input');
    const userRaw = input.value.trim();
    const entry = currentSession.currentEntry;
    if (entry && entry.mode === 'dictation-text') {
        checkDictationTextAnswer(userRaw);
        return;
    }
    if (entry && entry.mode === 'dictation') {
        checkDictationAnswer(userRaw);
        return;
    }
    const userValLower = userRaw.toLowerCase();
    const correctRaw = currentSession.currentCard.word;
    const correctLower = correctRaw.toLowerCase();
    // Determine correctness based on strictness
    let isCorrect = false;
    if (app.settings.strictness === 'strict') {
        isCorrect = userRaw === correctRaw;
    } else {
        isCorrect = userValLower === correctLower;
    }
    currentSession.isAnswered = true;
    currentSession.lastAnswerCorrect = isCorrect;
    document.getElementById('btn-check').classList.add('hidden');
    input.disabled = true;
    const feedback = document.getElementById('feedback');
    const positiveFeedback = [
        'Nice work!',
        'Great job!',
        'You got it!',
        'Nailed it!',
        'Smooth!'
    ];
    const extraPraise = positiveFeedback[Math.floor(Math.random() * positiveFeedback.length)];
    // Update performance statistics
    const card = currentSession.currentCard;
    const now = Date.now();
    let elapsed = 0;
    if (currentSession.startTime) {
        elapsed = (now - currentSession.startTime) / 1000;
    }
    // Compute average time (running average)
    const prevAttempts = (card.correctCount || 0) + (card.incorrectCount || 0);
    if (prevAttempts === 0) {
        card.avgTime = elapsed;
    } else {
        card.avgTime = ((card.avgTime || 0) * prevAttempts + elapsed) / (prevAttempts + 1);
    }
    if (isCorrect) {
        card.correctCount = (card.correctCount || 0) + 1;
    } else {
        card.incorrectCount = (card.incorrectCount || 0) + 1;
    }
    currentSession.totalAttempts += 1;
    if (isCorrect) {
        currentSession.correctAttempts += 1;
    } else {
        currentSession.troubleEntries.push(currentSession.currentEntry);
    }
    saveData();
    // Provide feedback
    if (isCorrect) {
        input.style.color = 'var(--success)';
        feedback.innerHTML = `
            <div class="feedback-positive">Correct!</div>
            <div class="feedback-sub">${extraPraise}</div>
        `;
        document.getElementById('srs-area').classList.remove('hidden');
    } else {
        input.style.color = 'var(--error)';
        const typedValue = input.value ? input.value : '';
        const diffMarkup = getWordDiffMarkup(currentSession.currentCard.word, typedValue, app.settings.strictness);
        feedback.innerHTML = `
            <div class="diff-display">
                <span class="diff-line">${diffMarkup}</span>
            </div>
            <div class="feedback-sub">Correct spelling with mistakes highlighted in red.</div>
            <div class="try-again-wrap">
                <button class="btn-secondary" onclick="retryCurrentCard()">Try again</button>
            </div>
        `;
    }
}

function checkDictationAnswer(userRaw) {
    const input = document.getElementById('p-input');
    const entry = currentSession.currentEntry;
    if (!entry) return;
    const correctSentence = entry.sentence || '';
    const isCorrect = isSentenceCorrect(correctSentence, userRaw, app.settings.strictness);
    currentSession.isAnswered = true;
    currentSession.lastAnswerCorrect = isCorrect;
    document.getElementById('btn-check').classList.add('hidden');
    input.disabled = true;
    const feedback = document.getElementById('feedback');
    const elapsed = getElapsedSeconds();
    const { mistakeCards, fallbackCard } = resolveDictationRatings(entry, userRaw);
    const ratedCards = mistakeCards.length ? mistakeCards : (fallbackCard ? [fallbackCard] : []);
    ratedCards.forEach(card => {
        const isCardCorrect = !mistakeCards.includes(card);
        applyDictationRating(card, entry.deck, elapsed, isCardCorrect);
        currentSession.totalAttempts += 1;
        if (isCardCorrect) {
            currentSession.correctAttempts += 1;
        } else {
            currentSession.troubleEntries.push({ deck: entry.deck, card });
        }
    });
    if (entry.deck && isDictationDeck(entry.deck)) {
        entry.deck.dictationStatsReady = true;
    }
    saveData();
    if (isCorrect) {
        input.style.color = 'var(--success)';
        feedback.innerHTML = `
            <div class="feedback-positive">Sentence correct!</div>
            <div class="feedback-sub">Nice work finishing that dictation.</div>
        `;
    } else {
        input.style.color = 'var(--error)';
        const diffMarkup = getSentenceDiffMarkup(correctSentence, userRaw, app.settings.strictness);
        const mistakeList = mistakeCards.map(card => card.word).join(', ');
        feedback.innerHTML = `
            <div class="diff-display">
                <span class="diff-line">${diffMarkup}</span>
            </div>
            <div class="feedback-sub">Review these words: <strong>${mistakeList || 'Check the sentence again'}</strong>.</div>
        `;
    }
    feedback.innerHTML += `
        <div class="try-again-wrap">
            <button class="btn-primary" onclick="advanceCurrentEntry()">Next sentence</button>
        </div>
    `;
}

function checkDictationTextAnswer(userRaw) {
    const input = document.getElementById('p-input');
    const entry = currentSession.currentEntry;
    if (!entry) return;
    const correctText = entry.text || '';
    const isCorrect = isTextCorrect(correctText, userRaw, app.settings.strictness);
    currentSession.isAnswered = true;
    currentSession.lastAnswerCorrect = isCorrect;
    document.getElementById('btn-check').classList.add('hidden');
    input.disabled = true;
    const feedback = document.getElementById('feedback');
    const elapsed = getElapsedSeconds();
    const mistakeCards = applyDictationTextStats(entry.deck, correctText, userRaw, elapsed);
    if (entry.deck) {
        entry.deck.lastPracticed = Date.now();
        saveData();
    }
    const totalWords = tokenizeWords(correctText).length || 1;
    currentSession.totalAttempts += totalWords;
    if (isCorrect) {
        currentSession.correctAttempts += totalWords;
    } else {
        const wrongCount = Math.min(mistakeCards.length, totalWords);
        currentSession.correctAttempts += Math.max(totalWords - wrongCount, 0);
    }
    if (isCorrect) {
        input.style.color = 'var(--success)';
        feedback.innerHTML = `
            <div class="feedback-positive">Text correct!</div>
            <div class="feedback-sub">Great work completing the full dictation.</div>
        `;
    } else {
        input.style.color = 'var(--error)';
        const diffMarkup = getSentenceDiffMarkup(correctText, userRaw, app.settings.strictness);
        feedback.innerHTML = `
            <div class="diff-display">
                <span class="diff-line">${diffMarkup}</span>
            </div>
            <div class="feedback-sub">Mistakes are highlighted in red. Focus on those words next.</div>
        `;
    }
    feedback.innerHTML += `
        <div class="try-again-wrap">
            <button class="btn-primary" onclick="advanceCurrentEntry()">Finish</button>
        </div>
    `;
    mistakeCards.forEach(card => {
        currentSession.troubleEntries.push({ deck: entry.deck, card });
    });
}

function advanceCurrentEntry() {
    if (!currentSession.currentEntry) return;
    currentSession.queue.shift();
    currentSession.completedCount += 1;
    nextCard();
}

function getElapsedSeconds() {
    const now = Date.now();
    if (!currentSession.startTime) return 0;
    return (now - currentSession.startTime) / 1000;
}

function retryCurrentCard() {
    const input = document.getElementById('p-input');
    const feedback = document.getElementById('feedback');
    if (!input || !feedback) return;
    currentSession.isAnswered = false;
    currentSession.lastAnswerCorrect = null;
    currentSession.startTime = app.settings.timerStart === 'show' ? Date.now() : null;
    input.disabled = false;
    input.value = '';
    input.style.color = 'var(--primary)';
    feedback.innerHTML = '';
    document.getElementById('btn-check').classList.remove('hidden');
    document.getElementById('srs-area').classList.add('hidden');
    input.focus();
}

function rateCard(quality) {
    const card = currentSession.currentCard;
    const entry = currentSession.currentEntry;
    
    // Simple SRS Logic
    if (quality < 3) {
        card.interval = 1;
        card.ease = Math.max(1.3, card.ease - 0.2);
    } else {
        if (card.interval === 0) card.interval = 1;
        else if (card.interval === 1) card.interval = 3;
        else card.interval = Math.ceil(card.interval * card.ease);
        
        card.ease = card.ease + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        if (card.ease < 1.3) card.ease = 1.3;
    }

    // Set Due Date
    const DAY_MS = 86400000;
    card.due = Date.now() + (quality < 3 ? 0 : card.interval * DAY_MS);

    if (entry && entry.deck) {
        entry.deck.lastPracticed = Date.now();
    }
    saveData();
    
    currentSession.queue.shift(); // Remove current
    const shouldRequeue = quality < 3 || currentSession.lastAnswerCorrect === false || quality === 1;
    if (shouldRequeue) {
        currentSession.queue.unshift(entry); // Re-queue immediately
    } else {
        currentSession.completedCount += 1;
    }
    
    nextCard();
}

// --- DECK MANAGEMENT ---
function renderDeckList() {
    const list = document.getElementById('deck-list');
    list.innerHTML = '';
    
    if (app.decks.length === 0) {
        list.innerHTML = `<div style="text-align:center; padding:var(--space-4); color:var(--text-sub);">
            No decks yet.<br>Click "+ New" to create one.
        </div>`;
        return;
    }

    app.decks.forEach(deck => {
        const dueCount = getDueCount(deck);
        const dictationLabel = isDictationDeck(deck) ? ' • Dictation text' : '';
        const div = document.createElement('div');
        div.className = 'deck-item';
        div.innerHTML = `
            <div class="deck-info">
                <h3>${deck.name}</h3>
                <small>${deck.lang} • ${deck.cards.length} cards • ${dueCount} due${dictationLabel}</small>
            </div>
            <div style="display:flex; gap:8px;">
                <button class="btn-secondary" onclick="openDeckActions('${deck.id}')">Edit</button>
                <button class="btn-primary" onclick="openPracticeOptionsModal('${deck.id}')">Practice</button>
            </div>
        `;
        list.appendChild(div);
    });
}

// --- PROGRESS RENDERING ---
function renderProgress() {
    const overviewEl = document.getElementById('progress-overview');
    const detailsEl = document.getElementById('progress-details');
    if (!overviewEl || !detailsEl) return;
    overviewEl.innerHTML = '';
    detailsEl.innerHTML = '';
    progressTroubleEntries = [];
    if (app.decks.length === 0) {
        overviewEl.innerHTML = '<div style="padding:var(--space-2); color:var(--text-sub); text-align:center;">No data yet.</div>';
        return;
    }
    let total = 0;
    let mastered = 0;
    let dueTotal = 0;
    const troubleList = [];
    const now = Date.now();
    app.decks.forEach(deck => {
        deck.cards.forEach(card => {
            total++;
            if (card.due <= now) {
                dueTotal++;
            }
            if (card.interval > 15) {
                mastered++;
            }
            troubleList.push({
                word: card.word,
                deck: deck.name,
                deckRef: deck,
                cardRef: card,
                incorrect: card.incorrectCount || 0,
                avgTime: card.avgTime || 0
            });
        });
    });
    const masteryPercent = total ? Math.round((mastered / total) * 100) : 0;
    const troubleCandidates = troubleList.filter(item => item.incorrect > 0 || item.avgTime > 0);
    const troubleCount = troubleCandidates.length;
    let overviewHTML = `
        <h3 style="margin-top:0;">Mastery</h3>
        <div class="progress-metrics">
            <div class="progress-metric">
                <div class="progress-metric-label">Mastered</div>
                <div class="progress-metric-value">${masteryPercent}%</div>
            </div>
            <div class="progress-metric">
                <div class="progress-metric-label">Due today</div>
                <div class="progress-metric-value">${dueTotal}</div>
            </div>
            <div class="progress-metric">
                <div class="progress-metric-label">Trouble count</div>
                <div class="progress-metric-value">${troubleCount}</div>
            </div>
        </div>
    `;
    overviewEl.innerHTML = overviewHTML;
    // Trouble words
    troubleCandidates.sort((a,b) => {
        if (b.incorrect !== a.incorrect) return b.incorrect - a.incorrect;
        return b.avgTime - a.avgTime;
    });
    const topTrouble = troubleCandidates.slice(0,5);
    progressTroubleEntries = topTrouble.map(item => ({ deck: item.deckRef, card: item.cardRef }));
    let detailsHTML = '<h3 style="margin-top:0;">Trouble words</h3>';
    detailsHTML += '<p class="text-small" style="color:var(--text-sub);">Tackle these to level up your mastery.</p>';
    if (topTrouble.length > 0) {
        detailsHTML += '<div class="progress-trouble-list">';
        topTrouble.forEach(item => {
            const avgTimeLabel = item.avgTime > 0 ? `${item.avgTime.toFixed(1)}s` : '—';
            detailsHTML += `
                <div class="progress-trouble-item">
                    <div>
                        <strong>${item.word}</strong>
                        <div class="text-small" style="color:var(--text-sub);">${item.deck} • ${item.incorrect} errors • Avg ${avgTimeLabel}</div>
                    </div>
                </div>
            `;
        });
        detailsHTML += '</div>';
    } else {
        detailsHTML += '<div class="text-small" style="color:var(--text-sub); margin-bottom:var(--space-2);">No trouble words yet. Keep practicing!</div>';
    }
    detailsHTML += `<button class="btn-primary" onclick="startProgressTroublePractice()" ${topTrouble.length ? '' : 'disabled'}>Practice trouble words</button>`;
    detailsEl.innerHTML = detailsHTML;
}

// Modal Logic
let activeDeckIdForEdit = null;
function openDeckModal() {
    document.getElementById('deck-modal').classList.add('open');
    document.getElementById('new-deck-name').value = '';
    document.getElementById('new-deck-text').value = '';
    showDeckPanel('create');
}
function closeDeckModal() {
    document.getElementById('deck-modal').classList.remove('open');
}
function showDeckPanel(panel) {
    const createToggle = document.getElementById('deck-toggle-create');
    const importToggle = document.getElementById('deck-toggle-import');
    const createPanel = document.getElementById('deck-panel-create');
    const importPanel = document.getElementById('deck-panel-import');
    if (panel === 'import') {
        createToggle.classList.remove('active');
        importToggle.classList.add('active');
        createPanel.classList.add('hidden');
        importPanel.classList.remove('hidden');
    } else {
        importToggle.classList.remove('active');
        createToggle.classList.add('active');
        importPanel.classList.add('hidden');
        createPanel.classList.remove('hidden');
    }
}
function triggerDeckImport() {
    document.getElementById('import-deck-file').click();
}
function focusDeckPaste() {
    const textArea = document.getElementById('import-deck-json');
    if (!textArea) return;
    textArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
    textArea.focus();
}
function importDeckFromPaste() {
    const textArea = document.getElementById('import-deck-json');
    if (!textArea) return;
    const raw = textArea.value.trim();
    if (!raw) {
        alert("Paste deck JSON first.");
        return;
    }
    try {
        const data = JSON.parse(raw);
        const decks = normalizeImportedDecks(data);
        if (!decks.length) {
            alert("Invalid deck JSON");
            return;
        }
        app.decks.push(...decks);
        saveData();
        renderDeckList();
        textArea.value = '';
        closeDeckModal();
    } catch (err) {
        alert("Invalid deck JSON");
    }
}
function saveDeck() {
    const name = document.getElementById('new-deck-name').value;
    const lang = document.getElementById('new-deck-lang').value;
    const text = document.getElementById('new-deck-text').value.trim();
    if (!name) return;
    
    app.decks.push({
        id: generateDeckId(),
        name,
        lang,
        cards: [],
        uncompleted: false,
        lastPracticed: null,
        text,
        dictationStatsReady: false
    });
    saveData();
    closeDeckModal();
    renderDeckList();
}

function manageCards(deckId) {
    activeDeckIdForEdit = deckId;
    document.getElementById('cards-modal').classList.add('open');
    renderCardList();
}
function closeCardsModal() {
    document.getElementById('cards-modal').classList.remove('open');
}

function openDeckActions(deckId) {
    activeDeckIdForEdit = deckId;
    const deck = app.decks.find(d => d.id === deckId);
    document.getElementById('deck-actions-title').textContent = deck ? deck.name : 'Deck Actions';
    document.getElementById('deck-actions-modal').classList.add('open');
}

function closeDeckActionsModal() {
    document.getElementById('deck-actions-modal').classList.remove('open');
}

function openPracticeOptionsModal(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    if (!deck) return;
    activePracticeDeckId = deckId;
    selectedPracticeMode = null;
    renderPracticeOptions(deck);
    document.getElementById('practice-options-modal').classList.add('open');
}

function closePracticeOptionsModal() {
    document.getElementById('practice-options-modal').classList.remove('open');
    activePracticeDeckId = null;
    selectedPracticeMode = null;
}

function renderPracticeOptions(deck) {
    const listEl = document.getElementById('practice-options-list');
    const titleEl = document.getElementById('practice-options-title');
    const noteEl = document.getElementById('practice-options-note');
    const startBtn = document.getElementById('practice-options-start');
    if (!listEl || !titleEl || !noteEl || !startBtn) return;
    titleEl.textContent = deck ? `${deck.name} practice` : 'Practice options';
    listEl.innerHTML = '';
    const options = getDeckPracticeOptions(deck);
    if (!options.length) {
        listEl.innerHTML = '<div class="text-small" style="color: var(--text-sub);">No practice options available yet.</div>';
        noteEl.textContent = '';
        startBtn.disabled = true;
        return;
    }
    options.forEach(option => {
        const div = document.createElement('div');
        div.className = 'practice-option';
        if (!option.available) div.classList.add('disabled');
        div.innerHTML = `
            <div class="practice-option-title">${option.label}</div>
            <div class="practice-option-desc">${option.description}</div>
        `;
        if (option.available) {
            div.addEventListener('click', () => {
                selectedPracticeMode = option.mode;
                renderPracticeOptions(deck);
            });
        }
        if (selectedPracticeMode === option.mode) {
            div.classList.add('selected');
        }
        listEl.appendChild(div);
    });
    const lockedOption = options.find(option => !option.available && option.reason);
    noteEl.textContent = lockedOption ? lockedOption.reason : '';
    startBtn.disabled = !selectedPracticeMode;
}

function startPracticeFromOptions() {
    if (!activePracticeDeckId || !selectedPracticeMode) return;
    const deck = app.decks.find(d => d.id === activePracticeDeckId);
    if (!deck) return;
    const entries = buildPracticeEntriesForMode(deck, selectedPracticeMode);
    if (!entries.length) {
        alert("No practice items available for this selection.");
        return;
    }
    closePracticeOptionsModal();
    startPracticeEntries(entries, [deck]);
}

function openDeckEditor() {
    closeDeckActionsModal();
    if (activeDeckIdForEdit) manageCards(activeDeckIdForEdit);
}

function openDeckStats() {
    closeDeckActionsModal();
    if (activeDeckIdForEdit) renderDeckProgress(activeDeckIdForEdit);
}

function openDeckMetaEditor() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    document.getElementById('edit-deck-name').value = deck.name || '';
    document.getElementById('edit-deck-lang').value = deck.lang || 'en-US';
    document.getElementById('edit-deck-text').value = deck.text || '';
    closeDeckActionsModal();
    document.getElementById('deck-meta-modal').classList.add('open');
}

function closeDeckMetaModal() {
    document.getElementById('deck-meta-modal').classList.remove('open');
}

function saveDeckMeta() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    const nameInput = document.getElementById('edit-deck-name');
    const langSelect = document.getElementById('edit-deck-lang');
    const textInput = document.getElementById('edit-deck-text');
    const newName = nameInput.value.trim();
    const newText = textInput.value.trim();
    if (!newName) {
        alert("Deck name can't be empty.");
        return;
    }
    deck.name = newName;
    deck.lang = langSelect.value;
    deck.text = newText;
    saveData();
    closeDeckMetaModal();
    renderDeckList();
    renderPracticeHome();
    renderProgress();
    if (document.getElementById('view-deck-progress').classList.contains('active')) {
        renderDeckProgress(deck.id);
    }
}

function clearDeckCompletion(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    if (deck) deck.uncompleted = false;
    if (Array.isArray(currentSession.decks)) {
        currentSession.decks.forEach(sessionDeck => {
            if (sessionDeck.id === deckId) sessionDeck.uncompleted = false;
        });
    }
    if (Array.isArray(currentSession.queue)) {
        currentSession.queue.forEach(entry => {
            if (entry.deck && entry.deck.id === deckId) {
                entry.deck.uncompleted = false;
            }
        });
    }
}

function resetDeckStats() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    if (!confirm(`Reset stats for "${deck.name}"? This will mark all words as new.`)) return;
    deck.cards.forEach(card => {
        card.due = 0;
        card.interval = 0;
        card.ease = 2.5;
        card.correctCount = 0;
        card.incorrectCount = 0;
        card.avgTime = 0;
    });
    clearDeckCompletion(deck.id);
    saveData();
    renderDeckProgress(deck.id);
    renderProgress();
    if (!currentSession.isActive && document.getElementById('view-practice').classList.contains('active')) {
        renderPracticeHome();
    }
}

function exportDeck() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    const str = JSON.stringify(deck, null, 2);
    const blob = new Blob([str], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const safeName = deck.name ? deck.name.replace(/[^a-z0-9-_]+/gi, '_') : 'deck';
    a.href = url;
    a.download = `${safeName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function deleteDeck() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    if (!deck) return;
    if (!confirm(`Delete "${deck.name}"? This cannot be undone.`)) return;
    app.decks = app.decks.filter(d => d.id !== activeDeckIdForEdit);
    currentSession.selectedDeckIds = currentSession.selectedDeckIds.filter(id => id !== activeDeckIdForEdit);
    saveData();
    closeDeckActionsModal();
    renderDeckList();
    if (currentSession.deck && currentSession.deck.id === activeDeckIdForEdit) {
        currentSession.deck = null;
        currentSession.queue = [];
    }
    activeDeckIdForEdit = null;
}

function renderCardList() {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    const container = document.getElementById('cards-list-content');
    container.innerHTML = '';
    
    if(deck.cards.length === 0) {
        container.innerHTML = '<div style="text-align:center; color:#999; padding:var(--space-3);">No cards yet</div>';
        return;
    }

    deck.cards.slice().reverse().forEach((card, index) => {
        const div = document.createElement('div');
        div.style = "display:flex; justify-content:space-between; align-items:center; padding: var(--space-2) 0; border-bottom:1px solid #f3f4f6;";
        const realIndex = deck.cards.length - 1 - index;
        div.innerHTML = `
            <div>
                <strong style="font-size:1.1rem;">${card.word}</strong>
                ${card.sentence ? `<div style="font-size:0.85rem; color:#666; margin-top:4px;">${card.sentence}</div>` : ''}
            </div>
            <button class="btn-icon" style="background:#fee2e2; color:var(--error); width:32px; height:32px;" onclick="deleteCard(${realIndex})">✕</button>
        `;
        container.appendChild(div);
    });
}

function addCardToDeck() {
    const w = document.getElementById('new-card-word');
    const s = document.getElementById('new-card-sentence');
    const a = document.getElementById('new-card-audio');
    if (!w.value) return;
    
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    deck.cards.push({
        word: w.value.trim(),
        sentence: s.value.trim(),
        audioUrl: a.value.trim() || '',
        due: 0,
        interval: 0,
        ease: 2.5,
        correctCount: 0,
        incorrectCount: 0,
        avgTime: 0
    });
    w.value = '';
    s.value = '';
    a.value = '';
    w.focus();
    saveData();
    renderCardList();
    renderDeckList();
}

function handlePracticeKeydown(event) {
    if (event.key !== "Enter") return;
    if (!currentSession.isActive || !currentSession.currentCard) return;
    if (!currentSession.isAnswered) return;
    if (!currentSession.lastAnswerCorrect) return;
    event.preventDefault();
    const quality = currentSession.lastAnswerCorrect ? 3 : 2;
    rateCard(quality);
}

function initCardInputListeners() {
    const inputs = [
        document.getElementById('new-card-word'),
        document.getElementById('new-card-sentence'),
        document.getElementById('new-card-audio')
    ].filter(Boolean);
    inputs.forEach(input => {
        input.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter') return;
            event.preventDefault();
            addCardToDeck();
        });
    });
}

function deleteCard(index) {
    const deck = app.decks.find(d => d.id === activeDeckIdForEdit);
    deck.cards.splice(index, 1);
    saveData();
    renderCardList();
    renderDeckList();
}

function renderDeckProgress(deckId) {
    const deck = app.decks.find(d => d.id === deckId);
    const overviewEl = document.getElementById('deck-progress-overview');
    const detailsEl = document.getElementById('deck-progress-details');
    const titleEl = document.getElementById('deck-progress-title');
    if (!deck || !overviewEl || !detailsEl || !titleEl) return;
    activeDeckIdForEdit = deckId;
    titleEl.textContent = `${deck.name} Progress`;
    overviewEl.innerHTML = '';
    detailsEl.innerHTML = '';
    if (deck.cards.length === 0) {
        overviewEl.innerHTML = '<div style="padding:var(--space-2); color:var(--text-sub); text-align:center;">No cards yet.</div>';
        navTo('deck-progress');
        return;
    }
    let total = 0;
    let newWords = 0;
    let learning = 0;
    let mastered = 0;
    let dueTotal = 0;
    let sumTime = 0;
    let countTime = 0;
    const troubleList = [];
    const now = Date.now();
    deck.cards.forEach(card => {
        total++;
        if (card.due <= now) {
            dueTotal++;
        }
        if (card.interval === 0) {
            newWords++;
        } else if (card.interval > 15) {
            mastered++;
        } else {
            learning++;
        }
        if (card.avgTime && card.avgTime > 0) {
            sumTime += card.avgTime;
            countTime++;
        }
        troubleList.push({
            word: card.word,
            deck: deck.name,
            incorrect: card.incorrectCount || 0,
            avgTime: card.avgTime || 0
        });
    });
    const avgTime = countTime > 0 ? (sumTime / countTime).toFixed(1) : 'N/A';
    let overviewHTML = '<table style="width:100%; border-collapse:collapse; font-size:0.95rem;">';
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Total words</th><td style="padding:8px 4px; text-align:right;">${total}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Due</th><td style="padding:8px 4px; text-align:right;">${dueTotal}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">New</th><td style="padding:8px 4px; text-align:right;">${newWords}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Learning</th><td style="padding:8px 4px; text-align:right;">${learning}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Mastered</th><td style="padding:8px 4px; text-align:right;">${mastered}</td></tr>`;
    overviewHTML += `<tr><th style="text-align:left; padding:8px 4px;">Average response time (s)</th><td style="padding:8px 4px; text-align:right;">${avgTime}</td></tr>`;
    overviewHTML += '</table>';
    overviewEl.innerHTML = overviewHTML;
    troubleList.sort((a,b) => {
        if (b.incorrect !== a.incorrect) return b.incorrect - a.incorrect;
        return b.avgTime - a.avgTime;
    });
    const topTrouble = troubleList.filter(t => t.incorrect > 0 || t.avgTime > 0).slice(0,10);
    if (topTrouble.length > 0) {
        let detailsHTML = '<h3 style="margin-top:0;">Trouble Words</h3>';
        detailsHTML += '<table style="width:100%; border-collapse:collapse; font-size:0.9rem;">';
        detailsHTML += '<tr><th style="text-align:left; padding:4px;">Word</th><th style="text-align:left; padding:4px;">Errors</th><th style="text-align:right; padding:4px;">Avg time (s)</th></tr>';
        topTrouble.forEach(item => {
            detailsHTML += `<tr><td style="padding:4px;">${item.word}</td><td style="padding:4px;">${item.incorrect}</td><td style="padding:4px; text-align:right;">${item.avgTime.toFixed ? item.avgTime.toFixed(1) : item.avgTime}</td></tr>`;
        });
        detailsHTML += '</table>';
        detailsEl.innerHTML = detailsHTML;
    } else {
        detailsEl.innerHTML = '<div style="padding:var(--space-2); color:var(--text-sub);">No trouble words yet. Keep practicing!</div>';
    }
    navTo('deck-progress');
}

// --- UTILS & INIT ---
function generateDeckId() {
    return `deck-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function getDueCount(deck, now = Date.now()) {
    if (!deck || !Array.isArray(deck.cards)) return 0;
    return deck.cards.filter(card => card.due <= now).length;
}

function getTodayCounts(now = Date.now()) {
    let dueCount = 0;
    let newCount = 0;
    let troubleCount = 0;
    let totalCards = 0;
    app.decks.forEach(deck => {
        deck.cards.forEach(card => {
            totalCards++;
            if (card.due <= now) dueCount++;
            if (card.interval === 0) newCount++;
            if ((card.incorrectCount || 0) > 0) troubleCount++;
        });
    });
    return { dueCount, newCount, troubleCount, totalCards };
}

function createSampleDeck() {
    return {
        id: generateDeckId(),
        name: "Sample English",
        lang: "en-US",
        uncompleted: false,
        lastPracticed: null,
        text: '',
        dictationStatsReady: false,
        cards: [
            {word: "necessary", sentence: "It is necessary to sleep well.", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "queue", sentence: "Wait in the queue.", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "apple", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "banana", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "books", sentence: "I forgot my books at home", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0},
            {word: "school", sentence: "", audioUrl: '', due: 0, interval: 0, ease: 2.5, correctCount: 0, incorrectCount: 0, avgTime: 0}
        ]
    };
}

function formatLastPracticed(timestamp) {
    if (!timestamp) return 'Never';
    const date = new Date(timestamp);
    if (Number.isNaN(date.getTime())) return 'Never';
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
}

function isDictationDeck(deck) {
    return Boolean(deck && deck.text && deck.text.trim());
}

function deckHasDictationStats(deck) {
    if (!deck) return false;
    if (deck.dictationStatsReady) return true;
    return deck.cards.some(card => (card.correctCount || 0) + (card.incorrectCount || 0) > 0);
}

function getDeckPracticeOptions(deck) {
    if (!deck) return [];
    const hasWords = Array.isArray(deck.cards) && deck.cards.length > 0;
    const hasSentences = getDictationSentences(deck).length > 0;
    const hasText = isDictationDeck(deck);
    const statsReady = !hasText || deckHasDictationStats(deck);
    const options = [
        {
            mode: 'word',
            label: 'Practice words',
            description: 'Spell individual words with sentence hints.',
            show: hasWords,
            available: hasWords && statsReady
        },
        {
            mode: 'sentence',
            label: 'Practice sentences',
            description: 'Type each sentence from the dictation.',
            show: hasSentences,
            available: hasSentences && statsReady
        },
        {
            mode: 'text',
            label: 'Practice full text',
            description: 'Dictation of the entire text in one go.',
            show: hasText,
            available: hasText
        }
    ];
    if (hasText && !statsReady) {
        options.forEach(option => {
            if (option.mode !== 'text') {
                option.available = false;
                option.reason = 'Complete the full text once to unlock word and sentence practice.';
            }
        });
    }
    return options.filter(option => option.show);
}

function buildPracticeEntriesForMode(deck, mode) {
    const now = Date.now();
    if (mode === 'word') {
        const dueEntries = buildWordEntries(deck, now, true);
        return dueEntries.length ? dueEntries : buildWordEntries(deck, now, false);
    }
    if (mode === 'sentence') {
        return buildDictationEntries(deck);
    }
    if (mode === 'text') {
        return buildDictationTextEntry(deck);
    }
    return [];
}

function splitTextIntoSentences(text) {
    if (!text) return [];
    const matches = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g);
    return matches ? matches.map(sentence => sentence.trim()).filter(Boolean) : [];
}

function getDictationSentences(deck) {
    const sentences = splitTextIntoSentences(deck.text || '');
    if (sentences.length) return sentences;
    const unique = [];
    const seen = new Set();
    deck.cards.forEach(card => {
        const sentence = (card.sentence || '').trim();
        if (sentence && !seen.has(sentence)) {
            seen.add(sentence);
            unique.push(sentence);
        }
    });
    return unique;
}

function buildDictationEntries(deck) {
    const sentences = getDictationSentences(deck);
    return sentences.map((sentence, index) => {
        const cards = deck.cards.filter(card => (card.sentence || '').trim() === sentence);
        return {
            deck,
            mode: 'dictation',
            sentence,
            sentenceIndex: index + 1,
            sentenceCount: sentences.length,
            cards,
            primaryCard: pickMostDifficultCard(cards)
        };
    }).filter(entry => entry.sentence);
}

function buildDictationTextEntry(deck) {
    if (!deck || !deck.text || !deck.text.trim()) return [];
    const sentences = splitTextIntoSentences(deck.text);
    return [{
        deck,
        mode: 'dictation-text',
        text: deck.text.trim(),
        sentenceCount: sentences.length
    }];
}

function buildWordEntries(deck, now = Date.now(), dueOnly = true) {
    if (!deck || !Array.isArray(deck.cards)) return [];
    const cards = dueOnly ? deck.cards.filter(card => card.due <= now) : deck.cards;
    return cards.map(card => ({ deck, card, mode: 'word' }));
}

function pickMostDifficultCard(cards) {
    if (!cards || !cards.length) return null;
    return cards.slice().sort((a, b) => {
        const aErrors = a.incorrectCount || 0;
        const bErrors = b.incorrectCount || 0;
        if (bErrors !== aErrors) return bErrors - aErrors;
        const aTime = a.avgTime || 0;
        const bTime = b.avgTime || 0;
        if (bTime !== aTime) return bTime - aTime;
        return (b.word || '').length - (a.word || '').length;
    })[0];
}

function tokenizeWords(text) {
    return text.match(/[\p{L}\p{N}']+/gu) || [];
}

function normalizeToken(token, strictness) {
    return strictness === 'strict' ? token : token.toLowerCase();
}

function escapeHtml(value) {
    const div = document.createElement('div');
    div.textContent = value;
    return div.innerHTML;
}

function getLcsMatchIndices(correctTokens, userTokens) {
    const m = correctTokens.length;
    const n = userTokens.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    for (let i = 1; i <= m; i += 1) {
        for (let j = 1; j <= n; j += 1) {
            if (correctTokens[i - 1] === userTokens[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    const matchIndices = new Set();
    let i = m;
    let j = n;
    while (i > 0 && j > 0) {
        if (correctTokens[i - 1] === userTokens[j - 1]) {
            matchIndices.add(i - 1);
            i -= 1;
            j -= 1;
        } else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i -= 1;
        } else {
            j -= 1;
        }
    }
    return matchIndices;
}

function getWordDiffMarkup(correctWord, userWord, strictness) {
    const correctChars = Array.from(correctWord || '');
    const userChars = Array.from(userWord || '');
    const normalizedCorrect = correctChars.map(char => normalizeToken(char, strictness));
    const normalizedUser = userChars.map(char => normalizeToken(char, strictness));
    const matchIndices = getLcsMatchIndices(normalizedCorrect, normalizedUser);
    return correctChars.map((char, index) => {
        const safeChar = escapeHtml(char);
        if (matchIndices.has(index)) {
            return `<span>${safeChar}</span>`;
        }
        return `<span class="diff-highlight">${safeChar}</span>`;
    }).join('');
}

function getSentenceDiffMarkup(correctSentence, userSentence, strictness) {
    const tokens = String(correctSentence || '').match(/[\p{L}\p{N}']+|[^\p{L}\p{N}']+/gu) || [];
    const correctWords = tokens.filter(token => /[\p{L}\p{N}']+/u.test(token)).map(token => normalizeToken(token, strictness));
    const userWordTokens = tokenizeWords(userSentence || '');
    const normalizedUser = userWordTokens.map(token => normalizeToken(token, strictness));
    const matchIndices = getLcsMatchIndices(correctWords, normalizedUser);
    let wordIndex = 0;
    return tokens.map(token => {
        if (/[\p{L}\p{N}']+/u.test(token)) {
            const isMatch = matchIndices.has(wordIndex);
            const safeToken = escapeHtml(token);
            wordIndex += 1;
            if (isMatch) return safeToken;
            if (userWordTokens.length === correctWords.length) {
                const userWord = userWordTokens[wordIndex - 1] || '';
                return getWordDiffMarkup(token, userWord, strictness);
            }
            return `<span class="diff-highlight">${safeToken}</span>`;
        }
        return escapeHtml(token);
    }).join('');
}

function isSentenceCorrect(correctSentence, userSentence, strictness) {
    if (strictness === 'strict') {
        return correctSentence.trim() === userSentence.trim();
    }
    const correctTokens = tokenizeWords(correctSentence).map(token => token.toLowerCase());
    const userTokens = tokenizeWords(userSentence).map(token => token.toLowerCase());
    if (correctTokens.length !== userTokens.length) return false;
    return correctTokens.every((token, index) => token === userTokens[index]);
}

function isTextCorrect(correctText, userText, strictness) {
    if (strictness === 'strict') {
        return correctText.trim() === userText.trim();
    }
    const correctTokens = tokenizeWords(correctText).map(token => token.toLowerCase());
    const userTokens = tokenizeWords(userText).map(token => token.toLowerCase());
    if (correctTokens.length !== userTokens.length) return false;
    return correctTokens.every((token, index) => token === userTokens[index]);
}

function resolveDictationRatings(entry, userSentence) {
    const strictness = app.settings.strictness;
    const correctTokens = tokenizeWords(entry.sentence || '');
    const userTokens = tokenizeWords(userSentence);
    const maxLen = Math.max(correctTokens.length, userTokens.length);
    const mistakeCounts = new Map();
    for (let i = 0; i < maxLen; i += 1) {
        const correctToken = correctTokens[i];
        if (!correctToken) continue;
        const userToken = userTokens[i];
        const normalizedCorrect = normalizeToken(correctToken, strictness);
        const normalizedUser = userToken ? normalizeToken(userToken, strictness) : '';
        if (!userToken || normalizedCorrect !== normalizedUser) {
            const prev = mistakeCounts.get(normalizedCorrect) || 0;
            mistakeCounts.set(normalizedCorrect, prev + 1);
        }
    }
    const mistakeCards = [];
    entry.cards.forEach(card => {
        const normalized = normalizeToken(card.word || '', strictness);
        const remaining = mistakeCounts.get(normalized) || 0;
        if (remaining > 0) {
            mistakeCards.push(card);
            mistakeCounts.set(normalized, remaining - 1);
        }
    });
    const fallbackCard = mistakeCards.length ? null : pickMostDifficultCard(entry.cards);
    return { mistakeCards, fallbackCard };
}

function getWordTokensWithSentence(text) {
    const sentences = splitTextIntoSentences(text || '');
    const tokens = [];
    sentences.forEach(sentence => {
        tokenizeWords(sentence).forEach(word => {
            tokens.push({ word, sentence });
        });
    });
    return tokens;
}

function getOrCreateCardForWord(deck, word, sentence) {
    const normalizedWord = normalizeToken(word, 'lenient');
    let card = deck.cards.find(item => normalizeToken(item.word || '', 'lenient') === normalizedWord);
    if (!card) {
        card = {
            word,
            sentence: sentence || '',
            audioUrl: '',
            due: 0,
            interval: 0,
            ease: 2.5,
            correctCount: 0,
            incorrectCount: 0,
            avgTime: 0
        };
        deck.cards.push(card);
    } else if (!card.sentence && sentence) {
        card.sentence = sentence;
    }
    return card;
}

function applyDictationTextStats(deck, correctText, userText, elapsedSeconds) {
    if (!deck) return [];
    const strictness = app.settings.strictness;
    const correctWordTokens = getWordTokensWithSentence(correctText);
    const normalizedCorrectWords = correctWordTokens.map(token => normalizeToken(token.word, strictness));
    const userWords = tokenizeWords(userText).map(token => normalizeToken(token, strictness));
    const matchIndices = getLcsMatchIndices(normalizedCorrectWords, userWords);
    const mistakeCards = [];
    correctWordTokens.forEach((token, index) => {
        if (matchIndices.has(index)) return;
        const card = getOrCreateCardForWord(deck, token.word, token.sentence);
        applyDictationRating(card, deck, elapsedSeconds, false);
        mistakeCards.push(card);
    });
    deck.dictationStatsReady = true;
    saveData();
    return mistakeCards;
}

function applyDictationRating(card, deck, elapsedSeconds, isCorrect) {
    if (!card) return;
    const prevAttempts = (card.correctCount || 0) + (card.incorrectCount || 0);
    if (prevAttempts === 0) {
        card.avgTime = elapsedSeconds;
    } else {
        card.avgTime = ((card.avgTime || 0) * prevAttempts + elapsedSeconds) / (prevAttempts + 1);
    }
    if (isCorrect) {
        card.correctCount = (card.correctCount || 0) + 1;
        applySrsRating(card, 3);
    } else {
        card.incorrectCount = (card.incorrectCount || 0) + 1;
        applySrsRating(card, 1);
    }
    if (deck) {
        deck.lastPracticed = Date.now();
    }
}

function applySrsRating(card, quality) {
    card.interval = Number(card.interval) || 0;
    if (quality < 3) {
        card.interval = 1;
        card.ease = Math.max(1.3, (card.ease || 2.5) - 0.2);
    } else {
        if (card.interval === 0) card.interval = 1;
        else if (card.interval === 1) card.interval = 3;
        else card.interval = Math.ceil(card.interval * (card.ease || 2.5));
        card.ease = (card.ease || 2.5) + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        if (card.ease < 1.3) card.ease = 1.3;
    }
    const DAY_MS = 86400000;
    card.due = Date.now() + (quality < 3 ? 0 : card.interval * DAY_MS);
}

function normalizeImportedDecks(raw) {
    let decks = [];
    if (Array.isArray(raw)) {
        decks = raw;
    } else if (raw && Array.isArray(raw.decks)) {
        decks = raw.decks;
    } else if (raw && raw.name && Array.isArray(raw.cards)) {
        decks = [raw];
    }
    return decks.map((deck) => {
        const existingId = deck.id && !app.decks.some(d => d.id === deck.id);
        const normalizedCards = Array.isArray(deck.cards) ? deck.cards.map(card => ({
            word: String(card.word || '').trim(),
            sentence: card.sentence ? String(card.sentence) : '',
            audioUrl: card.audioUrl ? String(card.audioUrl) : '',
            due: Number(card.due) || 0,
            interval: Number(card.interval) || 0,
            ease: typeof card.ease === 'number' ? card.ease : 2.5,
            correctCount: Number(card.correctCount) || 0,
            incorrectCount: Number(card.incorrectCount) || 0,
            avgTime: Number(card.avgTime) || 0
        })).filter(card => card.word) : [];
        return {
            id: existingId ? deck.id : generateDeckId(),
            name: deck.name ? String(deck.name) : 'Imported Deck',
            lang: deck.lang ? String(deck.lang) : 'en-US',
            cards: normalizedCards,
            uncompleted: Boolean(deck.uncompleted),
            lastPracticed: deck.lastPracticed ? Number(deck.lastPracticed) : null,
            text: deck.text ? String(deck.text) : '',
            dictationStatsReady: Boolean(deck.dictationStatsReady)
        };
    });
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function initSettingsListeners() {
    const speed = document.getElementById('setting-speed');
    speed.value = app.settings.speed || 1.0;
    document.getElementById('speed-val').textContent = speed.value;

    speed.addEventListener('input', (e) => {
        app.settings.speed = e.target.value;
        document.getElementById('speed-val').textContent = e.target.value;
        saveData();
    });

    const voiceModeEl = document.getElementById('setting-voice-mode');
    if (voiceModeEl) {
        voiceModeEl.value = app.settings.voiceMode || 'auto';
        updateVoiceModeUI();
        voiceModeEl.addEventListener('change', (e) => {
            app.settings.voiceMode = e.target.value;
            updateVoiceModeUI();
            saveData();
        });
    }

    document.getElementById('setting-voice').addEventListener('change', (e) => {
        app.settings.voiceURI = e.target.value;
        saveData();
    });

    // Autoplay toggle
    const autoplayEl = document.getElementById('setting-autoplay');
    if (autoplayEl) {
        autoplayEl.checked = Boolean(app.settings.autoplay);
        autoplayEl.addEventListener('change', (e) => {
            app.settings.autoplay = e.target.checked;
            saveData();
        });
    }
    const blockSuggestionsEl = document.getElementById('setting-block-suggestions');
    if (blockSuggestionsEl) {
        blockSuggestionsEl.checked = Boolean(app.settings.blockSuggestions);
        blockSuggestionsEl.addEventListener('change', (e) => {
            app.settings.blockSuggestions = e.target.checked;
            applySuggestionSettingToInput(document.getElementById('p-input'));
            saveData();
        });
    }
    // Strictness select
    const strictEl = document.getElementById('setting-strictness');
    if (strictEl) {
        strictEl.value = app.settings.strictness || 'strict';
        strictEl.addEventListener('change', (e) => {
            app.settings.strictness = e.target.value;
            saveData();
        });
    }
    // Timer start select
    const timerEl = document.getElementById('setting-timerStart');
    if (timerEl) {
        timerEl.value = app.settings.timerStart || 'audio';
        timerEl.addEventListener('change', (e) => {
            app.settings.timerStart = e.target.value;
            saveData();
        });
    }
}

function exportData() {
    const str = JSON.stringify(app);
    const blob = new Blob([str], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "spellmaster_backup.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

document.getElementById('import-file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        let decks = [];
        try {
            const data = JSON.parse(e.target.result);
            if (data.decks) {
                app = data;
                saveData();
                location.reload();
                return;
            }
            decks = normalizeImportedDecks(data);
            if (!decks.length) {
                alert("Invalid file");
                return;
            }
        } catch(err) { alert("Invalid file"); }
        if (!decks.length) return;
        app.decks.push(...decks);
        saveData();
        renderDeckList();
    };
    reader.readAsText(file);
});

document.getElementById('import-deck-file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = JSON.parse(event.target.result);
            const decks = normalizeImportedDecks(data);
            if (!decks.length) {
                alert("Invalid deck file");
                return;
            }
            app.decks.push(...decks);
            saveData();
            renderDeckList();
            closeDeckModal();
        } catch (err) {
            alert("Invalid deck file");
        }
    };
    reader.readAsText(file);
    e.target.value = '';
});

function resetApp() {
    if(confirm("Delete all data? This cannot be undone.")) {
        localStorage.removeItem('spellmaster_data_v2');
        location.reload();
    }
}

// --- BOOTSTRAP ---
initAudio();
loadData();
initCardInputListeners();
document.addEventListener('keydown', handlePracticeKeydown);

</script>
</body>
</html>
